<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pandaQ&#39;s Site</title>
  <subtitle>May the force be with you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xu-li.cn/"/>
  <updated>2018-04-12T16:06:39.385Z</updated>
  <id>http://xu-li.cn/</id>
  
  <author>
    <name>pandaQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次面试总结</title>
    <link href="http://xu-li.cn/2018/an-interview-summary/"/>
    <id>http://xu-li.cn/2018/an-interview-summary/</id>
    <published>2018-04-12T14:50:38.000Z</published>
    <updated>2018-04-12T16:06:39.385Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，最近出去面试了(嘘……看到了保密)，说下最近的一次，本来以为挺有希望的，但还是准备不充分，说了很多即兴不过脑子的回答，可能给人留下一种很不靠谱的感觉吧。不过这都不是最重点，重点是面试中被问到了一个很有“想法”的问题，当时我没能捋清思路，回答的不是很完美。但在我回来研究了一下之后，发现面试官给的答案其实也不对……whatever，我只想总结下这次值得学习的经历。<br><a id="more"></a></p>
<h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>印象中记得<code>document ready</code>是网页加载完成的标志事件。一般借助<code>jQuery</code>实现应用，常见的三种语法是：</p>
<ul>
<li><code>$(document).ready(callback)</code></li>
<li><code>$().ready(callback)</code></li>
<li><code>$(callback)</code></li>
</ul>
<p>作用是监听文档加载状态，在加载完成时调用回调函数做一些操作。</p>
<p>由于没有深入总结过，我的认知只停留在这个层次，直到我在面试中被问到这样一个问题</p>
<pre><code>如何判断一个页面完全加载完成?
</code></pre><ul>
<li>我的回答是通过<code>seleniumLibrary</code>的库关键字<code>确认页面title</code>以及<code>定位一个已知页面元素</code>是否存在</li>
<li>这个回答被质疑，定位页面中的一个元素的存在就能确认整个页面加载完成么？</li>
<li>质疑很合理，页面中会有异步数据请求然后重新渲染DOM的操作，如何确认异步请求完成？</li>
<li>我继续回答异步请求拿AJAX举例，成功或失败时都会用回调函数，可以做一些操作当作完成标志，比如弹个窗</li>
<li>虽然回答没有大的问题，但还不是提问者心里的答案</li>
<li>我想了一会儿又补充了一个方法，在文档最后追加一个<code>script</code>，里面append一个隐藏元素，然后定位该元素的存在</li>
<li>这个答案也被否定，现在想想确实风马牛不相及，当时脑子一定短路了</li>
</ul>
<p>最后我询问提问者能否给出好的解决方法，他说的是<code>document ready</code>。</p>
<p>说实话当时只感觉没get到提问者的问题点，翻译下他的问题应该是<code>页面加载完成有什么标志?</code>。</p>
<p>如果能get到这个点的话，我应该能反应过来。</p>
<p>甚至还能说一下<code>$(document).ready(callback)</code> 和 <code>window.onload = callback</code>的区别</p>
<p>不过回来后仍给我带来了一些思考？</p>
<ul>
<li><code>document ready</code>是文档同步加载完成（仅指页面内<code>&lt;html</code>&gt;标签所包含的元素）的标志没问题，也能监听异步的文档渲染么？</li>
<li>浏览器拿到服务端的html是如何完成解析的</li>
</ul>
<p>以下主要探讨这两个问题</p>
<h2 id="document-ready"><a href="#document-ready" class="headerlink" title="$(document).ready"></a>$(document).ready</h2><p>先说结论，<code>jquery ready</code>只是文档同步加载完成的标志，它并不能监测到<code>异步的文档渲染</code>。</p>
<p>实例验证如下：</p>
<p>延迟3秒向页面中添加一个<code>p</code>元素，并监听<code>document.ready</code>事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          alert(<span class="string">'document is ready'</span>)</div><div class="line">      &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">      this is a div</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        $(<span class="string">'body'</span>).append(<span class="string">"&lt;p&gt;You can't see me&lt;/p&gt;"</span>)</div><div class="line">      &#125;, <span class="number">3000</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>由于<code>alert</code>有中断浏览器渲染的作用，所以<code>alert</code>出现时，观察页面元素即可得出结论。</p>
<p>结果是:</p>
<ul>
<li>页面立即显示<code>alert</code>的内容</li>
<li>出现<code>alert</code>时，<code>&lt;div&gt;</code>和<code>&lt;button&gt;</code>元素已经存在，说明确实是加载完成才触发的<code>ready</code>事件。</li>
<li>点击alert的确认，三秒后添加的<code>&lt;p&gt;</code>元素出现，说明<code>alert</code>的中断确实起作用，且异步文档渲染不在<code>ready</code>事件监控范围内。</li>
</ul>
<p>如果觉得样例不够还可自行验证，我结合后端模拟了ajax请求，结论也是如此。</p>
<p>这里不再重复举例，因为原理都是一样的，异步的文档操作都是对文档的重绘或者重画，不算在当前页面加载的范围内。</p>
<p><code>jQuery ready</code>只是同步文档加载完成的标志，不参与异步的监听。</p>
<h2 id="文档渲染流程"><a href="#文档渲染流程" class="headerlink" title="文档渲染流程"></a>文档渲染流程</h2><p>根据<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState" target="_blank" rel="external">Web API</a><br>文档的加载状态 <code>Document.readyState</code> 分三个阶段</p>
<ul>
<li><code>loading</code>, 仍在加载</li>
<li><code>interactive</code>， 文档已经完成加载并解析完成，但例如图片，样式文件、子窗口等子资源仍在加载中。对应<code>jquery ready</code>事件，同步文档已经渲染完成，可以获取DOM。</li>
<li><code>complete</code>，所有子资源均加载完成，触发<code>load</code>事件。如果此时注册<code>window.onload</code>回调函数，则会被调用</li>
</ul>
<p>eg：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (<span class="built_in">document</span>.readyState) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">"loading"</span>:</div><div class="line">    <span class="comment">// The document is still loading.</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">"interactive"</span>:</div><div class="line">    <span class="comment">// The document has finished loading.</span></div><div class="line">    <span class="comment">// We can now access the DOM elements.</span></div><div class="line">    <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</div><div class="line">    span.textContent = <span class="string">"A &lt;span&gt; element."</span>;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(span);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">"complete"</span>:</div><div class="line">    <span class="comment">// The page is fully loaded.</span></div><div class="line">    <span class="keyword">let</span> CSS_rule = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>].cssRules[<span class="number">0</span>].cssText;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`The first CSS rule is: <span class="subst">$&#123;CSS_rule &#125;</span>`</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结来说，我们日常说的页面加载完成，基本指的是当前页面内的元素以同步的方式加载完成。</p>
<p>加载渲染会经历三个阶段：</p>
<ul>
<li>loading，加载中</li>
<li>interactive，加载完成（除了图片、样式、子窗口等元素），可以访问DOM元素，触发<code>jQuery ready</code>事件。</li>
<li>complete, 渲染完成（不包括异步的DOM操作），样式也有了，触发<code>load</code>事件，调用注册的<code>window.onload</code>函数</li>
</ul>
<h2 id="More-Details"><a href="#More-Details" class="headerlink" title="More Details"></a>More Details</h2><p>前两部分的总结，基本清楚了html文档的整体加载过程，知道了大体分三个阶段，每个阶段都有哪些标志，但还不够具体。</p>
<p>查阅资料得知页面的渲染机制如下流程图所示：</p>
<p><img src="http://opxo4bto2.bkt.clouddn.com/html_parsing.png" alt="html_parsing"></p>
<p>以webkit内核的渲染流程举例来说：</p>
<p><img src="http://opxo4bto2.bkt.clouddn.com/webkit-render-flow.png" alt="webkit-render-flow"></p>
<p>浏览器拿到html的解析由渲染引擎来做，这部分是不同于网络资源加载时的多线程，而是单线程的</p>
<ul>
<li>从<code>&lt;html&gt;</code>节点开始分析，从上到下</li>
<li>遇到<code>&lt;script&gt;</code>,对于外链的JavaScript文件，需要先加载该文件内容，再进行解析，然后立即执行。这整个过程都会<code>阻塞文档解析</code>，直到脚本执行完才会继续解析文档节点。所以一般<code>&lt;script&gt;</code>标签都建议放在最后的<code>&lt;/body&gt;</code>元素之前，HTML5提供<code>defer</code>和<code>async</code>两个属性支持延迟和异步加载JavaScript文件</li>
<li>针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化。<br>比如在执行脚本时，开启另外的线程(一般限制在2-6个)解析剩余的文档以找出并加载其他的待下载外部资源（不改变主线程的DOM树，仅优化加载外部资源）。</li>
<li>对样式的处理也会阻塞文档解析，加载外部样式时后续js和文档解析都不会继续进行</li>
<li>在脚本中请求样式信息，如果样式尚未加载或解析，将会得到<code>错误信息</code></li>
<li>为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在在让我回答</p>
<ul>
<li><p>如何确定一个页面完全加载完成？</p>
<ul>
<li>我的回答依然会是确认页面title以及确认页面是否包含一个或一些目标元素（熟悉seleniumLibray的同学应该清楚，有两个库关键字来做这个工作，<code>Title Should Be</code>和<code>Element Should Contain</code>，当然还有一个<code>Wait Until Element Contains</code>会更合适)<br>这里就算是考虑异步加载数据并重新渲染文档的情况，也可以把要加载的元素当做定位元素去确认。<br>如果非要纠结异步结束的标志，这题根本没法答。因为页面上如果存在10个异步操作，怎么确认谁是最后完成的那个呢？</li>
</ul>
</li>
<li><p>如何确定异步请求的结束？</p>
<ul>
<li>只能通过异步请求自身的消息监听，外部无法获取它的状态变化</li>
</ul>
</li>
<li><p><code>document ready</code>事件和<code>window load</code>事件分别是什么动作完成的标志</p>
<ul>
<li>前者是<code>当前文档内</code>（异步DOM操作不包含在内）的DOM树构建完成的标志，可以进行DOM操作了，但是还没有完成渲染</li>
<li>后者是整个页面加载并渲染完成的标志</li>
</ul>
</li>
<li><p>js的下载和执行顺序能保证么？</p>
<ul>
<li>js的下载顺序不能保证，因为网络部分是多线程下载的；执行顺序是可以保证的，会按照页面<code>&lt;script&gt;</code>标签出现的顺序执行内部同步代码（异步操作加入事件循环），因为渲染引擎是单线程的</li>
</ul>
</li>
<li><p>页面的解析渲染流程？</p>
<ul>
<li>从html头开始，一边解析一边渲染，主线程会被外部资源的加载以及js的执行阻塞，因此资源放置的位置以及顺序是有影响的</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState" target="_blank" rel="external">Web API</a></li>
<li>《WebKit技术内幕》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，最近出去面试了(嘘……看到了保密)，说下最近的一次，本来以为挺有希望的，但还是准备不充分，说了很多即兴不过脑子的回答，可能给人留下一种很不靠谱的感觉吧。不过这都不是最重点，重点是面试中被问到了一个很有“想法”的问题，当时我没能捋清思路，回答的不是很完美。但在我回来研究了一下之后，发现面试官给的答案其实也不对……whatever，我只想总结下这次值得学习的经历。&lt;br&gt;
    
    </summary>
    
      <category term="common-sense" scheme="http://xu-li.cn/categories/common-sense/"/>
    
    
      <category term="DOM" scheme="http://xu-li.cn/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>async/await</title>
    <link href="http://xu-li.cn/2018/async-await/"/>
    <id>http://xu-li.cn/2018/async-await/</id>
    <published>2018-02-28T13:15:27.000Z</published>
    <updated>2018-03-31T14:17:28.038Z</updated>
    
    <content type="html"><![CDATA[<p>async/await, 号称js异步的终极方案……虽然似乎只是语法糖，但确实减少了代码量，让代码同步化，一直拖着没用，但不学不行啊<br><a id="more"></a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li><code>async</code>修饰放在函数声明前，表示函数里有异步操作</li>
<li><code>async</code>函数的返回值会被封装为<code>promise</code>对象</li>
<li><code>await</code>只能出现在<code>async</code>函数中，表示后面的表达式需要等待结果，</li>
<li><code>await</code>后面的返回值一般是promise对象，如果不是也会被<code>Promise.resolve()</code>转换</li>
<li><code>await</code>后面的promise对象状态如果变为<code>reject</code>,会有<code>return</code> 的效果，不再执行后续语句</li>
<li>如果希望前一个异步失败不影响后面的状态，需要将<code>await</code>语句用<code>try...catch</code>包裹</li>
</ul>
<p>基本示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> timeout(ms);</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="string">'bye'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">2000</span>).then(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(ret);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>await状态转为失败时的处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 另一种写法</span></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="同时执行"><a href="#同时执行" class="headerlink" title="同时执行"></a>同时执行</h3><p><code>await</code>语句会保持顺序执行，如果不存在顺序关系的两个操作，可以并行执行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方式一</span></div><div class="line"><span class="keyword">var</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()])</div><div class="line"><span class="comment">//方式二</span></div><div class="line"><span class="keyword">let</span> fooPromise = getFoo();</div><div class="line"><span class="keyword">let</span> barPromise = getBar();</div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</div></pre></td></tr></table></figure></p>
<h3 id="await与for循环"><a href="#await与for循环" class="headerlink" title="await与for循环"></a>await与for循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>)=&gt;</span>&#123;</div><div class="line">    setTimeout(res, <span class="number">1000</span>*i, i)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</div><div class="line">        <span class="built_in">console</span>.time(i);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'ret: '</span> + <span class="keyword">await</span> f(i));</div><div class="line">        <span class="built_in">console</span>.timeEnd(i)</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">test()</div></pre></td></tr></table></figure>
<p>这段输出如下，for循环有被中断的效果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ret: <span class="number">0</span></div><div class="line"><span class="number">0</span>: <span class="number">5.512</span>ms</div><div class="line">ret: <span class="number">1</span></div><div class="line"><span class="number">1</span>: <span class="number">1000.404</span>ms</div><div class="line">ret: <span class="number">2</span></div><div class="line"><span class="number">2</span>: <span class="number">2000.869</span>ms</div><div class="line">ret: <span class="number">3</span></div><div class="line"><span class="number">3</span>: <span class="number">3001.408</span>ms</div><div class="line">ret: <span class="number">4</span></div><div class="line"><span class="number">4</span>: <span class="number">4000.921</span>ms</div></pre></td></tr></table></figure></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>async/await 从promise迁移过来使用还是很简单的，之前已经总结了部分错误处理</p>
<p>那就是<code>try...catch</code>,但每个await写个<code>try...catch</code>实在是不够优雅</p>
<p>那就简单写个封装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="literal">null</span>, ret]</div><div class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>[err])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    [err, ret] = <span class="keyword">await</span> to(getFoo())</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">    [err, ret] = <span class="keyword">await</span> to(getBar())</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然也没有多高级，但显然比<code>try...catch</code>要优雅的多……</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来想从ES6的generator开始总结起，然而ES6规范还没普及就被ES7的async/await干掉了……</p>
<p>不存在兼容性问题的情况下，直接使用async/await能让语义更清晰，也能减少代码量，值得学习和使用</p>
<p>参考资料：</p>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">async函数</a></li>
<li><a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/" target="_blank" rel="external">How to write async await without try-catch blocks in Javascript</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;async/await, 号称js异步的终极方案……虽然似乎只是语法糖，但确实减少了代码量，让代码同步化，一直拖着没用，但不学不行啊&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="javaScript" scheme="http://xu-li.cn/tags/javaScript/"/>
    
      <category term="async" scheme="http://xu-li.cn/tags/async/"/>
    
      <category term="await" scheme="http://xu-li.cn/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>基本数据结构：Python vs Javascript</title>
    <link href="http://xu-li.cn/2018/datatype-py-vs-js/"/>
    <id>http://xu-li.cn/2018/datatype-py-vs-js/</id>
    <published>2018-02-22T13:35:27.000Z</published>
    <updated>2018-04-07T02:45:15.019Z</updated>
    
    <content type="html"><![CDATA[<p>写多了nodejs再回来写python提笔就忘，说出来还被人说代码量少……嗯，无法反驳。<br>仔细想了下，徒手写代码到底困难在哪儿，想来大概是数据结构和基本语法了。<br>把这两种语言放一块儿对比着来总结下，主要就数据结构和基本语法两部分，备忘。<br><a id="more"></a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>六大基本类型以及引用类型</p>
<p>基本类型：number, string, boolean(true/false), null, undefined, Symbol<br>引用类型：Object</p>
<p>对象还可细分为 <code>Array</code>, <code>Functio</code>n, <code>Date</code>, <code>Math</code>等</p>
<p>ES6新增了<code>Set</code>和<code>Map</code>对象等</p>
<h3 id="py"><a href="#py" class="headerlink" title="py"></a>py</h3><p>基本类型和集合</p>
<p>基本类型：number, string, boolean(True/False), None(空值)<br>集合：list, tuple, set, dictionary</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="py-1"><a href="#py-1" class="headerlink" title="py"></a>py</h3><p>python的变量不用特殊声明，除非在局部作用域使用全局变量需要使用<code>global</code>声明</p>
<p>另外，python里一切皆对象，变量的赋值相当于将name和object绑定在一起<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a= <span class="number">3</span></div></pre></td></tr></table></figure></p>
<ul>
<li>创建name a</li>
<li>创建object 3</li>
<li>将name a 关联到 3这个object </li>
</ul>
<p>以后就可以用a来调用3这个object</p>
<h3 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h3><p>相比python，js就要显得麻烦一些</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>ES6新增<code>let</code>,<code>const</code>声明关键字</p>
<ul>
<li><code>let</code>，块级作用域</li>
<li><code>var</code>，函数作用域</li>
<li><code>const</code>， 声明变量值不可更改，对象则是指针的指向不可变</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a <span class="comment">// ReferenceError: a is not defined.</span></div><div class="line">b <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> i = <span class="string">'lalala'</span> <span class="comment">//不会报错，for循环体和循环条件是两个作用域</span></div><div class="line">  <span class="built_in">console</span>.log(i) </div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">//ReferenceError: i is not defined</span></div></pre></td></tr></table></figure>
<ul>
<li><code>var</code>可重复声明，后续变量值会覆盖前面</li>
<li><code>let</code>和<code>const</code>均不可重复声明，否则会报错</li>
</ul>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><ul>
<li><code>var</code>存在变量提升，</li>
<li><code>let</code>和<code>const</code>不存在变量提升</li>
<li>函数声明也会得到提升<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined, 声明未赋值</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">const</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>再举一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(tmp);</div><div class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure></p>
<p>输出不是当前日期，而是<code>undefined</code>, 因为函数内部tmp的声明被提升</p>
<p>虽然日常代码不会这么写，但非常具备迷惑性</p>
<h4 id="let和const的暂时性死区（Temporal-Dead-Zone）"><a href="#let和const的暂时性死区（Temporal-Dead-Zone）" class="headerlink" title="let和const的暂时性死区（Temporal Dead Zone）"></a>let和const的暂时性死区（Temporal Dead Zone）</h4><p>只要<code>块级作用域</code>内存在let或const命令，它所声明的变量就<code>绑定</code>（binding）这个区域，不再受外部的影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果注释掉let的声明，这段代码是没有问题的</p>
<p>但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错</p>
<pre><code>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
</code></pre><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><h3 id="js-2"><a href="#js-2" class="headerlink" title="js"></a>js</h3><ul>
<li><code>typeof</code>, 运算符，返回表达式数据类型的全小写<code>字符串</code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="number">123</span>       <span class="comment">// 'number'</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>       <span class="comment">// 'number'</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span>     <span class="comment">// 'string`</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span>      <span class="comment">// 'object'</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span>      <span class="comment">// 'boolean'</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> &#123;&#125;        <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">typeof</span> []        <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;    <span class="comment">// 'function'</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> unknownVariable <span class="comment">// 'undefined'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>数组的判断使用ES6里的新增方法<code>Array.isArray</code>, 接受一个参数返回布尔值。</p>
<p>或者自行如下实现<br><code>Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;</code></p>
<p><code>NaN</code>的判断使用<code>Number.isNaN</code></p>
<h3 id="py-2"><a href="#py-2" class="headerlink" title="py"></a>py</h3><ul>
<li><p><code>type(var)</code>,和已知变量类型对比</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type(myInt) <span class="keyword">is</span> type(<span class="number">1</span>)</div><div class="line">type(myFloat) <span class="keyword">is</span> type(<span class="number">.1</span>)</div><div class="line">type(myLong) <span class="keyword">is</span> type(<span class="number">1111111111111</span>)</div><div class="line">type(myBool) <span class="keyword">is</span> type(<span class="keyword">True</span>)</div><div class="line">type(myStr) <span class="keyword">is</span> type(<span class="string">"a"</span>)</div><div class="line">type(myList) <span class="keyword">is</span> type([<span class="number">1</span>])</div><div class="line">type(myTuple) <span class="keyword">is</span> type((<span class="number">1</span>,))</div><div class="line">type(mySet) <span class="keyword">is</span> type(set([<span class="number">1</span>]))</div><div class="line">type(myDict) <span class="keyword">is</span> type(&#123;<span class="number">1</span>:<span class="number">2</span>&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>isinstance(object, class-or-type-or-tuple)</code>, 返回布尔值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">isinstance(myInt, int)</div><div class="line">isinstance(myFloat, float)</div><div class="line">isinstance(myLong, float)</div><div class="line">isinstance(myBool, bool)</div><div class="line">isinstance(myStr, str)</div><div class="line">isinstance(myList, list)</div><div class="line">isinstance(myTuple, tuple)</div><div class="line">isinstance(mySet, set)</div><div class="line">isinstance(myDict, dict)</div><div class="line"><span class="comment"># 第二个参数使用tuple类型</span></div><div class="line">isinstance(myDict, (list, tuple, set, dict))</div></pre></td></tr></table></figure>
</li>
<li><p>内置库，types</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> types</div><div class="line"></div><div class="line">type(myInt) <span class="keyword">is</span> types.IntType</div><div class="line">type(myFloat) <span class="keyword">is</span> types.FloatType</div><div class="line">type(myLong) <span class="keyword">is</span> types.LongType</div><div class="line">type(myBool) <span class="keyword">is</span> types.BooleanType</div><div class="line">type(myStr) <span class="keyword">is</span> types.String</div><div class="line">type(myList) <span class="keyword">is</span> types.ListType</div><div class="line">type(myTuple) <span class="keyword">is</span> types.TupleType</div><div class="line"><span class="comment"># types库中没有对应的set类型，需要前两种方法</span></div><div class="line">type(myDict) <span class="keyword">is</span> types.DictType</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h2><h3 id="js-3"><a href="#js-3" class="headerlink" title="js"></a>js</h3><p>使用<code>===</code>,不建议使用<code>==</code>来自找麻烦<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="literal">null</span> === <span class="literal">null</span>            <span class="comment">//true</span></div><div class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span>  <span class="comment">//true</span></div><div class="line">&#123;&#125; === &#123;&#125;                <span class="comment">//false</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>              <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h3 id="py-3"><a href="#py-3" class="headerlink" title="py"></a>py</h3><p>判断相等，python和js出入较大</p>
<p>python的对象包含三要素:id，type，value</p>
<ul>
<li><code>is</code>，id和value都相等</li>
<li><code>==</code>，value相等</li>
<li><code>!=</code>，value不相等<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a = b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">d = &#123;<span class="string">'a'</span>:<span class="number">1</span>&#125; </div><div class="line">e = &#123;<span class="string">'a'</span>:<span class="number">1</span>&#125; </div><div class="line"></div><div class="line"><span class="keyword">print</span> a == b  <span class="comment"># True</span></div><div class="line"><span class="keyword">print</span> a == c  <span class="comment"># True !!!</span></div><div class="line"><span class="keyword">print</span> a <span class="keyword">is</span> b  <span class="comment"># True</span></div><div class="line"><span class="keyword">print</span> a <span class="keyword">is</span> c  <span class="comment"># True</span></div><div class="line"><span class="keyword">print</span> d == e  <span class="comment"># True !!!</span></div><div class="line"><span class="keyword">print</span> <span class="keyword">None</span> <span class="keyword">is</span> <span class="keyword">None</span> <span class="comment"># True</span></div><div class="line"><span class="keyword">print</span> <span class="keyword">None</span> == <span class="keyword">None</span> <span class="comment"># True</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里主要说明了<code>is</code>和<code>==</code>的区别。同时也引出了第二个问题，对象相等</p>
<p>另外同一类的实例对象，一般是不相等，因为内存地址不同</p>
<p>但可以重载<code>__eq__</code>方法实现定制</p>
<p>与之相反的是<code>__ne__</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name=name</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.name == other.name</div><div class="line"></div><div class="line"><span class="keyword">print</span> Foo(<span class="string">'zhangsan'</span>) == Foo(<span class="string">'lisi'</span>)     <span class="comment"># False</span></div><div class="line"><span class="keyword">print</span> Foo(<span class="string">'zhangsan'</span>) == Foo(<span class="string">'zhangsan'</span>) <span class="comment"># True</span></div></pre></td></tr></table></figure></p>
<p>从而不难理解为什么python里引用类型也会出现相等的情况了，其实只是单纯的值相等而已</p>
<h2 id="假值"><a href="#假值" class="headerlink" title="假值"></a>假值</h2><h3 id="js-4"><a href="#js-4" class="headerlink" title="js"></a>js</h3><ul>
<li><code>false</code> (boolean)</li>
<li>空字符串</li>
<li>数值为<code>0</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3></li>
<li><code>False</code> (boolean)</li>
<li>空序列，包括空字符串, [], {}, ()</li>
<li>数值为<code>0</code></li>
<li><code>None</code></li>
</ul>
<h2 id="判断及循环"><a href="#判断及循环" class="headerlink" title="判断及循环"></a>判断及循环</h2><h3 id="js-5"><a href="#js-5" class="headerlink" title="js"></a>js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if/else</span></div><div class="line"><span class="keyword">if</span>()&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//while</span></div><div class="line"><span class="keyword">while</span>()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//for</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;  <span class="comment">//i: index or key</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> array_obj)&#123; <span class="comment">//x: value</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># if/else</span></div><div class="line"><span class="keyword">if</span> cond:</div><div class="line">    statement</div><div class="line"><span class="keyword">elif</span> cond:</div><div class="line">    statement</div><div class="line"><span class="keyword">else</span></div><div class="line">    statement</div><div class="line"></div><div class="line"><span class="comment"># while</span></div><div class="line"><span class="keyword">while</span> cond:</div><div class="line">    statement</div><div class="line"></div><div class="line"><span class="comment"># for, 任何可迭代的对象都可以for循环</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> array_list:</div><div class="line">    <span class="keyword">print</span> value</div><div class="line"></div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range[len(array_list)]</div><div class="line">    <span class="keyword">print</span> index</div><div class="line"></div><div class="line">d = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>)]  </div><div class="line"><span class="comment"># 迭代二元list </span></div><div class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> d:  </div><div class="line">    <span class="keyword">print</span> x, y</div><div class="line"></div><div class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span>, <span class="string">'Paul'</span>: <span class="number">74</span> &#125;  </div><div class="line"></div><div class="line"><span class="comment"># 迭代dict的键，相当于将字典转换成key的list，相比iterkeys更费内存 </span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> d.keys():  </div><div class="line">    <span class="keyword">print</span> x  </div><div class="line">  </div><div class="line"><span class="comment"># 也可以采用这种方式迭代  </span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> d.iterkeys():  </div><div class="line">    <span class="keyword">print</span> x  </div><div class="line">  </div><div class="line"><span class="comment"># 迭代dict的值  </span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> d.values():  </div><div class="line">    <span class="keyword">print</span> x  </div><div class="line">  </div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> d.itervalues():  </div><div class="line">    <span class="keyword">print</span> x  </div><div class="line">  </div><div class="line"><span class="comment"># 迭代键值对  </span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():  </div><div class="line">    <span class="keyword">print</span> k, <span class="string">":"</span>, v  </div><div class="line">  </div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems():  </div><div class="line">    <span class="keyword">print</span> k, <span class="string">":"</span>, v</div></pre></td></tr></table></figure>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><h3 id="js-6"><a href="#js-6" class="headerlink" title="js"></a>js</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组 - []"></a>数组 - <code>[]</code></h4><ul>
<li>索引越界访问返回<code>undefined</code></li>
</ul>
<p>常用属性方法：</p>
<ul>
<li><code>length</code> 返回数组长度</li>
<li><code>push(element1[, ...[, elementN]])</code>,</li>
<li><code>unshift(element1[, ...[, elementN]])</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>sort([compareFunction])</code>, 默认从小到大</li>
<li><code>includes()</code></li>
<li><code>join()</code>， 返回字符串，默认逗号分隔</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象 - {}"></a>对象 - <code>{}</code></h4><ul>
<li>key-value赋值，点运算符或<code>[属性名]</code>均可</li>
<li>访问不存在的属性返回<code>undefined</code></li>
<li><code>key</code>一般为字符串</li>
<li>for循环取到的是key值</li>
<li>ES6 支持对象属性解构</li>
<li><code>Object.keys(obj)</code>,返回对象可枚举属性的字符串数组</li>
<li><code>Object.values(obj)</code>,返回对象可枚举属性值的数组</li>
</ul>
<h3 id="py-4"><a href="#py-4" class="headerlink" title="py"></a>py</h3><h4 id="list"><a href="#list" class="headerlink" title="list - []"></a>list - <code>[]</code></h4><ul>
<li>索引越界访问返回<code>IndexError</code></li>
<li><code>-1</code>做索引可以取到最后一个元素，依次类推</li>
<li>获取长度使用<code>len(list_var)</code></li>
</ul>
<p>常用属性方法</p>
<ul>
<li><code>append(element)</code>, 追加元素到末尾</li>
<li><code>insert(index, element)</code>, 查人元素到指定位置</li>
<li><code>pop(index)</code>, 删除指定位置的元素，返回该元素</li>
</ul>
<p>列表生成器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">l = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>)]</div></pre></td></tr></table></figure></p>
<p>将中括号<code>[]</code>换成括号<code>()</code>,即返回一个生成器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">3</span>))</div><div class="line"><span class="keyword">print</span> next(g) <span class="comment"># 0</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g:</div><div class="line">    <span class="keyword">print</span> x</div><div class="line"><span class="comment"># 1</span></div><div class="line"><span class="comment"># 4</span></div></pre></td></tr></table></figure></p>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple - ()"></a>tuple - <code>()</code></h4><p>和list类似，但是tuple一旦初始化就<code>不能修改</code>（指向）</p>
<p>也因此没有动态修改的方法，只有通过索引来访问值</p>
<p>定义一个tuple使用<code>t=()</code><br>但是定义一个元素的tuple要使用<code>t=(1,)</code>,否则会返回<code>数字1</code></p>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict - {}"></a>dict - <code>{}</code></h4><ul>
<li><p>访问通过索引或者<code>get</code>方法</p>
<ul>
<li>通过索引访问的key不存在会报<code>keyError</code></li>
<li>通过get方法，返回None或指定值<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;d[<span class="string">'tom'</span>] = <span class="number">7</span></div><div class="line">&gt;&gt;&gt;d[<span class="string">'jerry'</span>]</div><div class="line">keyError</div><div class="line">&gt;&gt;&gt;d.get(<span class="string">'jerry'</span>, <span class="number">-1</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>key</code>值可以是任意类型，但必须是<code>不可变对象</code></p>
</li>
<li><code>pop(key)</code>, 删除指定key，返回value</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set - ([])"></a>set - <code>([])</code></h3><p>和<code>dict</code>类似，但set只是一组key的集合，key值不重复，且不包含value</p>
<p>重复值会被过滤掉，且不保证顺序，是数学意义上的无序不重复元素的集合</p>
<ul>
<li><p>初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### 直接定义</span></div><div class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;     <span class="comment">#set([1,2,3])</span></div><div class="line"></div><div class="line"><span class="comment">### 接受一个list参数</span></div><div class="line">s= set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]) <span class="comment">#set([1,2,3])</span></div></pre></td></tr></table></figure>
</li>
<li><p>set的元素只能是不可变对象，可变对象无法哈希化确定唯一值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &#123;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)&#125;    <span class="comment"># ok</span></div><div class="line">s = &#123;(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>])&#125;  <span class="comment"># typeError</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>常用方法</p>
<ul>
<li><code>add(key)</code>, 添加新元素，重复添加无效</li>
<li><code>remove(key)</code>, 删除元素</li>
<li><code>s1 &amp; s2</code>, 取交集</li>
<li><code>s1 | s2</code>, 取并集</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写多了nodejs再回来写python提笔就忘，说出来还被人说代码量少……嗯，无法反驳。&lt;br&gt;仔细想了下，徒手写代码到底困难在哪儿，想来大概是数据结构和基本语法了。&lt;br&gt;把这两种语言放一块儿对比着来总结下，主要就数据结构和基本语法两部分，备忘。&lt;br&gt;
    
    </summary>
    
      <category term="common-sense" scheme="http://xu-li.cn/categories/common-sense/"/>
    
    
      <category term="javaScript" scheme="http://xu-li.cn/tags/javaScript/"/>
    
      <category term="python" scheme="http://xu-li.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>包机制：Python vs Node.js</title>
    <link href="http://xu-li.cn/2018/package-in-python-and-nodejs/"/>
    <id>http://xu-li.cn/2018/package-in-python-and-nodejs/</id>
    <published>2018-01-31T12:45:27.000Z</published>
    <updated>2018-04-07T02:44:50.720Z</updated>
    
    <content type="html"><![CDATA[<p>专注在nodejs上有一段时间了，回头看看python发现忘得差不多了，还是得多做做总结加强记忆啊。<br>先从包机制入手，对比来看下python和nodejs的异同<br><a id="more"></a></p>
<h2 id="python-package"><a href="#python-package" class="headerlink" title="python package"></a>python package</h2><h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>python将一个文件或一个文件夹视为一个模块</p>
<p>如果是文件件，需要显示的创建<code>__init__.py</code>来标明</p>
<p>模块内定义的所有变量都可以被导出</p>
<p>python中的变量不强制使用前声明，默认为局部变量，但使用前必须被定义或赋值</p>
<p>全局变量需要用<code>global</code>声明</p>
<h3 id="导出模块-1"><a href="#导出模块-1" class="headerlink" title="导出模块"></a>导出模块</h3><p>python2.6以后及python3 默认支持的是绝对引用，也推荐这种方式</p>
<p>通过<code>import</code>关键字引入模块, 模块名不需要带<code>.py</code>后缀<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pkg</div><div class="line"><span class="keyword">from</span> pkg <span class="keyword">import</span> foo</div><div class="line"><span class="keyword">from</span> pkg.moduleA <span class="keyword">import</span> foo</div><div class="line"><span class="keyword">from</span> pkg.moduleA <span class="keyword">import</span> foo <span class="keyword">as</span> bar</div><div class="line"><span class="keyword">from</span> pkg <span class="keyword">import</span> *</div></pre></td></tr></table></figure></p>
<p>python解释器会自动在<code>sys.path</code>下去搜索<code>pkg</code>包</p>
<p>windows下可以定义<code>PYTHONPATH</code>使得路径永久生效</p>
<p><code>python -m</code>的方案可解决一些包引入错误，原理即使将<code>当前目录</code>加到<code>sys.path</code>中，<br>相当于提供了顶级目录。</p>
<p>引入模块的时候会执行内部代码，一些不想在引入时执行的内容一般处理如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># pkg.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'123'</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> __name__  <span class="comment">#pkg</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    test()</div></pre></td></tr></table></figure></p>
<p>当作为模块引入时<code>__name__</code> 为包名，直接执行时为<code>__main__</code>, 以此来做区分</p>
<p>引入一个文件夹包，相当于引入它目录下的<code>__init__.py</code>, 一般为空文件</p>
<p>如果在里面引入子模块，则后续可以用<code>.</code>的形式链式调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">pkg</div><div class="line">├── __init__.py</div><div class="line">└── main.py</div><div class="line">test.py</div><div class="line">"""</div><div class="line"><span class="comment"># main.py</span></div><div class="line">a = <span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment"># __init__.py 为空时，从test.py 引入变量a</span></div><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="keyword">from</span> pkg.main <span class="keyword">import</span> a</div><div class="line"><span class="keyword">print</span> a</div><div class="line"></div><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">import</span> main</div><div class="line"></div><div class="line"><span class="comment"># 可以在__init__.py中提前引入模块，方便后续调用</span></div><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="keyword">import</span> pkg</div><div class="line"><span class="keyword">print</span> pkg.main.a</div></pre></td></tr></table></figure></p>
<p>模块的<code>__all__</code>变量可以定制对外暴露的对象，不在其中的内容不能被外部引用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">pkg</div><div class="line">├── test.py</div><div class="line">└── main.py</div><div class="line">"""</div><div class="line"><span class="comment"># main.py</span></div><div class="line">__all__ = [<span class="string">'a'</span>]</div><div class="line"></div><div class="line">a = <span class="number">2</span></div><div class="line">b = <span class="number">3</span></div><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="keyword">from</span> main <span class="keyword">import</span> *</div><div class="line"><span class="keyword">print</span> a</div><div class="line"><span class="keyword">print</span> b</div></pre></td></tr></table></figure></p>
<p>执行 <code>test.py</code>,会得到错误<code># NameError: name &#39;b&#39; is not defined</code></p>
<p>注释掉<code>__all__</code>那行就不会报错了</p>
<h2 id="node-package"><a href="#node-package" class="headerlink" title="node package"></a>node package</h2><h3 id="导出模块-2"><a href="#导出模块-2" class="headerlink" title="导出模块"></a>导出模块</h3><p>node中一个文件就是一个模块</p>
<p>如果是文件夹，则目录下的<code>index.js</code>为默认导出文件</p>
<p>导出的内容和python不同，<code>必须</code>显性指定到<code>module.exports</code>上，该值默认为<code>{}</code></p>
<p>ES6的语法，则是利用<code>export</code>关键字去实现导出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">exports = <span class="built_in">module</span>.exports = &#123;&#125;</div><div class="line"><span class="comment">//ES6 </span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;a&#125;</div><div class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> b&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</div></pre></td></tr></table></figure></p>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>node中包导入方式：</p>
<ul>
<li>传统的<code>require</code>函数</li>
<li>ES6的<code>import</code>函数</li>
</ul>
<p>先看require函数的用法</p>
<h4 id="模块名导入"><a href="#模块名导入" class="headerlink" title="模块名导入"></a>模块名导入</h4><p>直接使用<code>不带路径</code>的模块名一般为内置包或安装的第三方包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h4><p>导入模块的后缀可省<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'./index'</span>)</div></pre></td></tr></table></figure></p>
<p>会寻找当前目录下的<code>index.js</code>,如果不存在则认为<code>index</code>是一个文件夹，<br>继续寻找<code>./index/index.js</code></p>
<h4 id="绝对路径导入"><a href="#绝对路径导入" class="headerlink" title="绝对路径导入"></a>绝对路径导入</h4><p>没什么可说的，参数数为模块的绝对路径</p>
<h4 id="import函数的用法"><a href="#import函数的用法" class="headerlink" title="import函数的用法"></a>import函数的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></div><div class="line"><span class="keyword">import</span> _, &#123; each, each <span class="keyword">as</span> forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>python 和 nodejs 均以单个文件为<code>module</code>, 同时也支持文件夹的包裹，细分又有很多不同</p>
<p>二者包的路径查找也有很大区别，python需要保证包在系统路径下，添加PYTHON_PATH可以永久添加</p>
<p>nodejs是在当前目录下查找，同时也支持全局安装包</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;专注在nodejs上有一段时间了，回头看看python发现忘得差不多了，还是得多做做总结加强记忆啊。&lt;br&gt;先从包机制入手，对比来看下python和nodejs的异同&lt;br&gt;
    
    </summary>
    
      <category term="package" scheme="http://xu-li.cn/categories/package/"/>
    
      <category term="Python" scheme="http://xu-li.cn/categories/package/Python/"/>
    
      <category term="Node.js" scheme="http://xu-li.cn/categories/package/Python/Node-js/"/>
    
    
      <category term="python" scheme="http://xu-li.cn/tags/python/"/>
    
      <category term="module" scheme="http://xu-li.cn/tags/module/"/>
    
      <category term="node.js" scheme="http://xu-li.cn/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>express源码中的对象继承</title>
    <link href="http://xu-li.cn/2018/express-object-inheritance/"/>
    <id>http://xu-li.cn/2018/express-object-inheritance/</id>
    <published>2018-01-10T13:50:38.000Z</published>
    <updated>2018-02-09T13:35:23.130Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs web框架<code>express</code>源码中, 多处封装涉及到了对象继承，单独拿出来总结下它们的特点，参考学习<br><a id="more"></a></p>
<h2 id="对象继承方式"><a href="#对象继承方式" class="headerlink" title="对象继承方式"></a>对象继承方式</h2><p>简单阅读源码所看到的对象继承方式有三种</p>
<ul>
<li>merge-descriptors</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> mixin = <span class="built_in">require</span>(<span class="string">'merge-descriptors'</span>);</div><div class="line"><span class="comment">//app对象从EventEmitter.prototype对象继承</span></div><div class="line">mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<ul>
<li>Object.create()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.request对象从req对象继承，并定义app属性</span></div><div class="line">app.request = <span class="built_in">Object</span>.create(req, &#123;</div><div class="line">    <span class="attr">app</span>: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<ul>
<li>Object.setPrototypeOf()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> setPrototypeOf = <span class="built_in">require</span>(<span class="string">'setprototypeof'</span>)</div><div class="line"><span class="comment">//将router对象的原型对象设置为proto</span></div><div class="line">setPrototypeOf(router, proto)</div></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这应该是最常用的的三种继承形式了</p>
<h3 id="属性拷贝"><a href="#属性拷贝" class="headerlink" title="属性拷贝"></a>属性拷贝</h3><p>第一种为属性值拷贝，没什么技巧就是把要继承的属性全部拷贝到自己身上, 可以选择是否覆盖同名属性</p>
<p>源码的实现如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//merge-descriptors</span></div><div class="line"><span class="built_in">module</span>.exports = merge</div><div class="line"></div><div class="line"><span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Merge the property descriptors of `src` into `dest`</div><div class="line"> *</div><div class="line"> * @param &#123;object&#125; dest Object to add descriptors to</div><div class="line"> * @param &#123;object&#125; src Object to clone descriptors from</div><div class="line"> * @param &#123;boolean&#125; [redefine=true] Redefine `dest` properties with `src` properties</div><div class="line"> * @returns &#123;object&#125; Reference to dest</div><div class="line"> * @public</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">dest, src, redefine</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!dest) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument dest is required'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!src) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument src is required'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (redefine === <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="comment">// Default to true</span></div><div class="line">    redefine = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(src).forEach(<span class="function"><span class="keyword">function</span> <span class="title">forEachOwnPropertyName</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!redefine &amp;&amp; hasOwnProperty.call(dest, name)) &#123;</div><div class="line">      <span class="comment">// Skip desriptor</span></div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Copy descriptor</span></div><div class="line">    <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(src, name)</div><div class="line">    <span class="built_in">Object</span>.defineProperty(dest, name, descriptor)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> dest</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>拷贝继承，继承时会耗费更多时间和空间，但后续访问时理论上效率更高</p>
<p>常驻于内存中的对象更加适合这种继承方式, 一次继承多次使用</p>
<p>后两种可归为一类，均是从原型对象继承</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>原型继承，是js中常见的的继承方式，这里有两种操作方法</p>
<ul>
<li><p><code>Object.create(proto[, propertiesObject])</code></p>
<pre><code>返回在指定原型对象上添加新属性后的对象
即除了继承之外，还可以自定义属性
</code></pre></li>
<li><p><code>setprototypeof</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//setprototypeof</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="built_in">Object</span>.setPrototypeOf || (&#123;<span class="attr">__proto__</span>:[]&#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? setProtoOf : mixinProperties);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProtoOf</span>(<span class="params">obj, proto</span>) </span>&#123;</div><div class="line">	obj.__proto__ = proto;</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixinProperties</span>(<span class="params">obj, proto</span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> proto) &#123;</div><div class="line">		<span class="keyword">if</span> (!obj.hasOwnProperty(prop)) &#123;</div><div class="line">			obj[prop] = proto[prop];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般来说调用的是原生接口<code>Object.setPrototypeOf</code></p>
<p>同时也提供了两种兼容方案</p>
<ul>
<li><code>obj.__proto__ = proto;</code> </li>
<li>属性值拷贝</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己写代码或者写库程序不可避免会涉及到继承封装，express提供了很好的最佳实践</p>
<ul>
<li>对于常驻对象推荐使用<code>属性拷贝</code>，用空间换时间</li>
<li>原型继承有<code>Object.create()</code>和<code>Object.setPrototypeOf()</code>等方法，分别有各自适合的场景，更多了解可以参照MDN的说明</li>
<li>不想自己造轮子，express的这俩久经考验的轮子也可以直接拿来使用，<code>merge-descriptors</code>和<code>setPrototypeOf</code>, 源码也十分简洁</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs web框架&lt;code&gt;express&lt;/code&gt;源码中, 多处封装涉及到了对象继承，单独拿出来总结下它们的特点，参考学习&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="express" scheme="http://xu-li.cn/tags/express/"/>
    
      <category term="Object-inheritance" scheme="http://xu-li.cn/tags/Object-inheritance/"/>
    
  </entry>
  
  <entry>
    <title>middleware</title>
    <link href="http://xu-li.cn/2018/middleware/"/>
    <id>http://xu-li.cn/2018/middleware/</id>
    <published>2018-01-08T12:50:38.000Z</published>
    <updated>2018-02-08T14:44:09.757Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs的经典web框架中很多均实现了中间件系统，设计合理，使用也十分方便，本文主要总结这些精简api背后的源码实现<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>nodejs的web框架应该都是基于原生httpServer实现的，先回到原点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    res.end(<span class="string">'hello world'</span>)</div><div class="line">&#125;).listen(<span class="number">3000</span>)</div></pre></td></tr></table></figure></p>
<p>nodejs提供了足够简单的api，几行代码就能构建一个http服务器</p>
<p>运行后访问<code>http://127.0.0.1:3000/</code>, 应该就能看到熟悉的字符</p>
<h2 id="中间件概念"><a href="#中间件概念" class="headerlink" title="中间件概念"></a>中间件概念</h2><p>在这里请允许我对中间件做一个望文生义的解释</p>
<pre><code>一个请求可能需要被多次处理，将处理流程模块化，每一个处理环节即为中间件
处理结束后可以选择终止处理返回结果，也可以将控制权转交给下一个模块
</code></pre><p>这是我根据框架的功能实现总结的概念，不够全面，但足够清晰</p>
<h2 id="connect的实现"><a href="#connect的实现" class="headerlink" title="connect的实现"></a>connect的实现</h2><p>选择connect来说明是因为它足够精简<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'connect'</span>);</div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = connect();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</div><div class="line">  log(<span class="string">'middleware 1'</span>)</div><div class="line">  next()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</div><div class="line">  log(<span class="string">'middleware 2'</span>)</div><div class="line">  next()</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// respond to all requests</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    log(<span class="string">'middleware 3'</span>)</div><div class="line">  res.end(<span class="string">'Hello from Connect!\n'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//create node.js http server and listen on port</span></div><div class="line">http.createServer(app).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure></p>
<p>connect的api也十分简单</p>
<ul>
<li>通过<code>app.use</code>注册中间件</li>
<li><code>next</code>函数做流程控制，处理结束后显示的调用next函数进入下一个中间件</li>
</ul>
<p>运行后访问<code>http://127.0.0.1:3000/</code>, 应该可以看到控制台的依次打印</p>
<ul>
<li>middleware 1</li>
<li>middleware 2</li>
<li>middleware 3</li>
</ul>
<h2 id="connect源码分析"><a href="#connect源码分析" class="headerlink" title="connect源码分析"></a>connect源码分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = createServer;</div><div class="line"></div><div class="line"><span class="keyword">var</span> proto = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">'utils-merge'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res, next</span>)</span>&#123; app.handle(req, res, next); &#125;</div><div class="line">  merge(app, proto);</div><div class="line">  merge(app, EventEmitter.prototype);</div><div class="line">  app.route = <span class="string">'/'</span>;</div><div class="line">  app.stack = [];</div><div class="line">  <span class="keyword">return</span> app;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个connect模块对外接口为一个函数，调用后仍然返回一个app函数</p>
<p>先看注册流程</p>
<h3 id="中间件注册"><a href="#中间件注册" class="headerlink" title="中间件注册"></a>中间件注册</h3><p><code>app.use</code>实现了中间件的挂载, api有如下几类</p>
<ul>
<li><code>app.use(path, func)</code>, 第一个参数为注册路径，如果省略则默认为<code>/</code>, 将匹配所有请求，第二个参数为一个函数，即对该请求做相应处理</li>
<li><code>app.use(path， _app)</code>, <code>_app</code>是和<code>app</code>一样，均为<code>connect()</code>返回的函数对象，是第一类api的特殊情况，相当于挂载子应用</li>
<li><code>app.use(path, httpServer)</code>, 同上，也是特殊处理的情况，接受一个httpServer对象，处理时调用它的第一个请求处理函数</li>
</ul>
<p>源码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">route, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> handle = fn;</div><div class="line">  <span class="keyword">var</span> path = route;</div><div class="line"></div><div class="line">  <span class="comment">// default route to '/'</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> route !== <span class="string">'string'</span>) &#123;</div><div class="line">    handle = route;</div><div class="line">    path = <span class="string">'/'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// wrap sub-apps</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle.handle === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">var</span> server = handle;</div><div class="line">    server.route = path;</div><div class="line">    handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">      server.handle(req, res, next);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// wrap vanilla http.Servers</span></div><div class="line">  <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> http.Server) &#123;</div><div class="line">    handle = handle.listeners(<span class="string">'request'</span>)[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// strip trailing slash</span></div><div class="line">  <span class="keyword">if</span> (path[path.length - <span class="number">1</span>] === <span class="string">'/'</span>) &#123;</div><div class="line">    path = path.slice(<span class="number">0</span>, <span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// add the middleware</span></div><div class="line">  debug(<span class="string">'use %s %s'</span>, path || <span class="string">'/'</span>, handle.name || <span class="string">'anonymous'</span>);</div><div class="line">  <span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>了解了api再来看源码，会清楚很多，做的事情即：</p>
<ul>
<li>中间件注册时需两个参数</li>
<li>第一个是路径参数，如果省略则默认为<code>/</code>，匹配所有路径。</li>
<li>第二个参数为处理参数（有普通函数，子应用，httpServer对象，共三种不同的表现形式）</li>
<li>随后路径和处理函数会被打包成一个对象存储在数组<code>app.stack</code>中</li>
</ul>
<p>完了再看处理流程</p>
<h3 id="中间件调用"><a href="#中间件调用" class="headerlink" title="中间件调用"></a>中间件调用</h3><p>app函数接受三个参数，对比原生api，多了一个next参数，在不了解的情况下，我们可以先做个如下实验<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</div><div class="line">    res.end(<span class="string">'goodbye world'</span>)</div><div class="line">    <span class="built_in">console</span>.log(next)</div><div class="line">&#125;).listen(<span class="number">3000</span>)</div></pre></td></tr></table></figure></p>
<p>运行后访问，控制台打印为<code>undefined</code>, 可以肯定这个参数并非一开始存在的，而是后续封装的</p>
<p>通过<code>http.createServer(app).listen(3000);</code>可知，当有请求消息时，处理流程为</p>
<pre><code>app(req, res) =&gt; app.handle(req, res, next) 
此时的next为undefined
</code></pre><p>继续看app.handle函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> protohost = getProtohost(req.url) || <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> removed = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> slashAdded = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.stack;</div><div class="line"></div><div class="line">  <span class="comment">// final function handler</span></div><div class="line">  <span class="keyword">var</span> done = out || finalhandler(req, res, &#123;</div><div class="line">    <span class="attr">env</span>: env,</div><div class="line">    <span class="attr">onerror</span>: logerror</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// store the original URL</span></div><div class="line">  req.originalUrl = req.originalUrl || req.url;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (slashAdded) &#123;</div><div class="line">      req.url = req.url.substr(<span class="number">1</span>);</div><div class="line">      slashAdded = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (removed.length !== <span class="number">0</span>) &#123;</div><div class="line">      req.url = protohost + removed + req.url.substr(protohost.length);</div><div class="line">      removed = <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// next callback</span></div><div class="line">    <span class="keyword">var</span> layer = stack[index++];</div><div class="line"></div><div class="line">    <span class="comment">// all done</span></div><div class="line">    <span class="keyword">if</span> (!layer) &#123;</div><div class="line">      defer(done, err);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// route data</span></div><div class="line">    <span class="keyword">var</span> path = parseUrl(req).pathname || <span class="string">'/'</span>;</div><div class="line">    <span class="keyword">var</span> route = layer.route;</div><div class="line"></div><div class="line">    <span class="comment">// skip this layer if the route doesn't match</span></div><div class="line">    <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</div><div class="line">      <span class="keyword">return</span> next(err);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// skip if route match does not border "/", ".", or end</span></div><div class="line">    <span class="keyword">var</span> c = path[route.length];</div><div class="line">    <span class="keyword">if</span> (c !== <span class="literal">undefined</span> &amp;&amp; <span class="string">'/'</span> !== c &amp;&amp; <span class="string">'.'</span> !== c) &#123;</div><div class="line">      <span class="keyword">return</span> next(err);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// trim off the part of the url that matches the route</span></div><div class="line">    <span class="keyword">if</span> (route.length !== <span class="number">0</span> &amp;&amp; route !== <span class="string">'/'</span>) &#123;</div><div class="line">      removed = route;</div><div class="line">      req.url = protohost + req.url.substr(protohost.length + removed.length);</div><div class="line"></div><div class="line">      <span class="comment">// ensure leading slash</span></div><div class="line">      <span class="keyword">if</span> (!protohost &amp;&amp; req.url[<span class="number">0</span>] !== <span class="string">'/'</span>) &#123;</div><div class="line">        req.url = <span class="string">'/'</span> + req.url;</div><div class="line">        slashAdded = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// call the layer handle</span></div><div class="line">    call(layer.handle, route, err, req, res, next);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然是个大函数，但做的事情很简单</p>
<ul>
<li>接受三个参数</li>
<li>变量<code>done</code>被设置为<code>finalhandler</code>函数的返回值</li>
<li>定义<code>next</code>函数</li>
<li>调用<code>next</code>函数</li>
</ul>
<p>next函数内部的操作：</p>
<ul>
<li>按顺序从<code>app.stack</code>中取出一个对象</li>
<li>如果不匹配，递归调用<code>next</code>函数，相当于取下一个对象</li>
<li>如果遍历完都没有匹配的，调用<code>done</code>函数</li>
<li>匹配成功，调用<code>call(layer.handle, route, err, req, res, next)</code></li>
</ul>
<p>层层包装，到了<code>call</code>函数这里就是最后一层了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">handle, route, err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arity = handle.length;</div><div class="line">  <span class="keyword">var</span> error = err;</div><div class="line">  <span class="keyword">var</span> hasError = <span class="built_in">Boolean</span>(err);</div><div class="line"></div><div class="line">  debug(<span class="string">'%s %s : %s'</span>, handle.name || <span class="string">'&lt;anonymous&gt;'</span>, route, req.originalUrl);</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (hasError &amp;&amp; arity === <span class="number">4</span>) &#123;</div><div class="line">      <span class="comment">// error-handling middleware</span></div><div class="line">      handle(err, req, res, next);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasError &amp;&amp; arity &lt; <span class="number">4</span>) &#123;</div><div class="line">      <span class="comment">// request-handling middleware</span></div><div class="line">      handle(req, res, next);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// replace the error</span></div><div class="line">    error = e;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// continue</span></div><div class="line">  next(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>通过handle函数（注册时的处理函数）形参个数来做不同处理，4个参数则是错误处理，3个参数则是请求处理</li>
<li>不管是成功还是失败，next均作为参数传入</li>
<li>如果处理错误继续调用next(err)</li>
</ul>
<p>至此，前文的流程可以继续走了</p>
<p>如果匹配到注册路径的中间件，则</p>
<pre><code>app(req, res) =&gt; app.handle(req, res, undefined) =&gt; handle(req, res, next)
</code></pre><p>如果中间抛出错误，且注册了错误处理函数（相比正常的错误函数多了一个参数，形如func(err, req, res, next))</p>
<pre><code>app(req, res) =&gt; app.handle(req, res, undefined) =&gt; handle(err,req, res, next)
</code></pre><p>如果一个都没匹配到</p>
<pre><code>app(req, res) =&gt; app.handle(req, res, undefined) =&gt; finalhandler(req, res, {env: env,onerror: logerror})(err)
</code></pre><p>next函数是通过闭包的方式实现，手动决定控制权的转移，也能控制错误的冒泡处理</p>
<p>至此，connect的原理基本都解析完毕了，源码就一个文件，注释加空行不到三百行但实现的功能却非常巧妙，如果你已经非常熟悉了中间件的api，那么这份源码非常值得一看</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结即是看完源码，写完上面一大坨后闭上眼看还剩下啥</p>
<ul>
<li>中间件的概念，自己编</li>
<li>中间件的实现，注册路径和处理函数，存在一个数组中，后续根据请求路径遍历数组，因此注册顺序很重要</li>
<li>控制权转让，手动调用next()即进入下一个中间件，如果出错也可以传递错误参数next(err), 交给后续错误处理中间件集中处理</li>
<li><p>中间件函数类型</p>
<pre><code>普通处理函数，处理完调下一个，此时必须有三个参数，eg：func(req, res, next)
响应返回函数，最后一道程序，处理完返回结果，此时不需要next函数，所以注册时两个或三个参数均可
错误处理函数，原则上应该放在最后注册，且参数必须为四个, eg: func(err, req, res, next), 当然可以注册多个错误处理函数，不同的错误依旧可通过next(err)向后传递
</code></pre></li>
<li>next 函数的实现，闭包，内部保留有存储中间件的数组以及传入的初始索引，递归调用或当做参数传递调用，可以达到遍历数组的效果</li>
</ul>
<p>嗯……似乎没啥剩下了，就这么多</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs的经典web框架中很多均实现了中间件系统，设计合理，使用也十分方便，本文主要总结这些精简api背后的源码实现&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="http://xu-li.cn/tags/Node-js/"/>
    
      <category term="middleware" scheme="http://xu-li.cn/tags/middleware/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest</title>
    <link href="http://xu-li.cn/2017/xhr/"/>
    <id>http://xu-li.cn/2017/xhr/</id>
    <published>2017-12-29T12:50:38.000Z</published>
    <updated>2018-02-25T04:05:03.216Z</updated>
    
    <content type="html"><![CDATA[<p>据说前端培训班第一课就会讲<code>XMLHttpRequest</code>和<code>AJAX</code>。<br>不说别的，至少能得出结论，这是个很基础，很重要的概念。<br>我没去过培训班，在此总结一下，如果被问到这个问题，我会怎么回答。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>XMLHttpRequest (XHR) 是干嘛用的</p>
<pre><code>使用xhr对象发送http请求和服务器通信
你可以通过一个url传输和获取服务端的数据
因为以前多用来传递xml格式的数据，所以名字里有个xml
但xhr可以发送和接收多种类型的数据资源（现在更多的是JSON、html、text files）
</code></pre></li>
<li><p>XHR 是什么</p>
<pre><code>是一个API
是一个类
是一个构造函数
</code></pre></li>
<li><p>为什么要用XHR</p>
<pre><code>支持页面局部更新
不用整体刷新页面，不会打断用户操作，用户体验好
</code></pre></li>
<li><p>哪些地方用到了XHR    </p>
<pre><code>XMLHttpRequest 在 AJAX 中被大量使用
</code></pre></li>
<li><p>所以AJAX 又是啥</p>
<pre><code>全称Asynchronous JavaScript And XML
它使用XHR对象和服务器通信
它是XHR的一个封装
特点是Asynchronous（异步）
</code></pre><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3></li>
</ul>
<p>XMLHttpRequest 是一个底层封装好的API, 通过它可以很容易的取回一个 URL 上的资源数据。尽管名字里有 XML，但 XMLHttpRequest 支持的数据类型并不局限于 XML。而且除了 HTTP ，它还支持 file 和 ftp 协议。</p>
<p>AJAX 则是对XMLHttpRequest的进一步封装，让使用更加方便</p>
<p>了解XMLHttpRequest，对AJAX的理解会更加深入</p>
<p>本文着重讲XMLHttpRequest</p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>想通过javascript发送一个http请求，我们需要一个具有必备功能的对象去做这件事，这个对象就是<code>XMLHttpRequest</code>对象</p>
<p>这个概念最初由微软设计，在IE中作为一个”ActiveX”对象使用，被称作”XMLHTTP”,随后 Mozilla、Apple 和 Google跟进,<br>搞出了一个”XMLHttpRequest”对象，功能上和ActiveX对象差不多。如今，该对象已经被 W3C组织标准化。</p>
<p>以下代码可以很好的说明这段历史<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Old compatibility code, no longer needed.</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123; <span class="comment">// Mozilla, Safari, IE7+ ...</span></div><div class="line">    httpRequest = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123; <span class="comment">// IE 6 and older</span></div><div class="line">    httpRequest = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现代浏览器直接调用构造函数<code>new XMLHttpRequest()</code>即可创建一个新的xhr对象</p>
<hr>
<p>对象有了，怎么发送请求呢，当然调用对象方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">httpRequest.open(<span class="string">'GET'</span>, <span class="string">'http://www.example.org/some.file'</span>, <span class="literal">true</span>);</div><div class="line">httpRequest.send();</div></pre></td></tr></table></figure></p>
<h3 id="xhr-open-requestMethod-url-isAsync"><a href="#xhr-open-requestMethod-url-isAsync" class="headerlink" title="xhr.open(requestMethod, url, isAsync)"></a>xhr.open(requestMethod, url, isAsync)</h3><ul>
<li>第一个参数是http请求方法名，安装http标准应该全部为大写字母</li>
<li>发送请求的url地址，出于安全性考虑，采用同源策略</li>
<li>可选参数，是否异步（js继续执行，未收到服务器响应前用户可继续与页面交互），默认为true</li>
</ul>
<h3 id="xhr-send"><a href="#xhr-send" class="headerlink" title="xhr.send()"></a>xhr.send()</h3><ul>
<li>发送请求参数</li>
<li>如果是POST请求，发送表单数据时应该以一种服务器可以解析的格式，例如query字符串的形式</li>
<li>支持多种格式的数据发送，multipart/form-data, JSON, XML 等等.</li>
<li>如果是使用POST发送数据，还需要设定请求的MIME类型，即定义请求头部</li>
</ul>
<p>下例表示请求里的参数类型为query字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">httpRequest.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">httpRequest.send(<span class="string">"name=value&amp;anothername="</span>+<span class="built_in">encodeURIComponent</span>(myVar)+<span class="string">"&amp;so=on"</span>)</div></pre></td></tr></table></figure></p>
<hr>
<p>发送请求后，需要接受响应。</p>
<p>在这个阶段，需要告诉xhr对象调用哪个函数去处理响应。</p>
<p>通过设置<code>onreadystatechange</code>属性值为一个函数，会在请求状态变化时调用</p>
<h3 id="xhr-onreadystatechange"><a href="#xhr-onreadystatechange" class="headerlink" title="xhr.onreadystatechange"></a>xhr.onreadystatechange</h3><ul>
<li>属性值为一个函数引用</li>
<li>函数无参数</li>
<li>相当于回调函数，处理服务器的响应</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpRequest.onreadystatechange = nameOfTheFunction;</div></pre></td></tr></table></figure>
<p>处理函数如何处理响应呢，答案是根据请求状态</p>
<h3 id="xhr-readyState"><a href="#xhr-readyState" class="headerlink" title="xhr.readyState"></a>xhr.readyState</h3><ul>
<li>0 (uninitialized) or (request not initialized)</li>
<li>1 (loading) or (server connection established)</li>
<li>2 (loaded) or (request received)</li>
<li>3 (interactive) or (processing request)</li>
<li>4 (complete) or (request finished and response is ready)</li>
</ul>
<p>details:</p>
<ul>
<li>0, <code>UNSENT</code>, Client has been created. open() not called yet.</li>
<li>1, <code>OPENED</code>, open() has been called.</li>
<li>2, <code>HEADERS_RECEIVED</code>, send() has been called, and headers and status are available.</li>
<li>3, <code>LOADING</code>, Downloading; responseText holds partial data.</li>
<li>4, <code>DONE</code>, The operation is complete.</li>
</ul>
<p>因此，响应处理函数的内容可以是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</div><div class="line">    <span class="comment">// Everything is good, the response was received.</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Not ready yet.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，还可以参考http响应的状态码，如<code>200 ok</code>来确认响应结果</p>
<h3 id="xhr-status"><a href="#xhr-status" class="headerlink" title="xhr.status"></a>xhr.status</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</div><div class="line">    <span class="comment">// Perfect!</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// There was a problem with the request.</span></div><div class="line">    <span class="comment">// For example, the response may have a 404 (Not Found)</span></div><div class="line">    <span class="comment">// or 500 (Internal Server Error) response code.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="xhr-responseType"><a href="#xhr-responseType" class="headerlink" title="xhr.responseType"></a>xhr.responseType</h3><p>属性<code>responseType</code>决定了响应的数据类型，如果返回的数据类型不符合设定，响应值将被置成<code>null</code></p>
<p>该属性只在异步请求中可用，同步请求设置该值会报错</p>
<p>支持的标准responseType如下：</p>
<ul>
<li><code>&quot;&quot;</code>, DOMString(default)</li>
<li><code>&quot;arraybuffer&quot;</code></li>
<li><code>&quot;blob&quot;</code></li>
<li><code>&quot;document&quot;</code></li>
<li><code>&quot;json&quot;</code></li>
<li><code>&quot;text&quot;</code>, DOMString</li>
</ul>
<h3 id="xhr-response"><a href="#xhr-response" class="headerlink" title="xhr.response"></a>xhr.response</h3><p>返回对应<code>responseType</code>中的内容实体</p>
<h3 id="xhr-responseText"><a href="#xhr-responseText" class="headerlink" title="xhr.responseText"></a>xhr.responseText</h3><p>将响应数据以<code>text</code>类型返回一个DOMString</p>
<h3 id="xhr-responseURL"><a href="#xhr-responseURL" class="headerlink" title="xhr.responseURL"></a>xhr.responseURL</h3><p>返回请求的url，如果不存在则返回空字符串</p>
<h3 id="xhr-responseXML"><a href="#xhr-responseXML" class="headerlink" title="xhr.responseXML"></a>xhr.responseXML</h3><p>返回一个XML 文档解析而来的 DOM 对象，也可用来解析HTML，设置responseType为document即可</p>
<h3 id="xhr-timeout"><a href="#xhr-timeout" class="headerlink" title="xhr.timeout"></a>xhr.timeout</h3><p>超时时长，单位为ms</p>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>对于相同请求，浏览器会默认缓存结果，不会重复提交请求。如果要请求相同内容，记得设置请求头部<code>Cache-Control: no-cache</code></li>
<li><p>请求报错时，错误会在响应处理函数内部抛出，可以使用try…catch捕获</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertContents</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</div><div class="line">      <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</div><div class="line">        alert(httpRequest.responseText);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">'There was a problem with the request.'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span>( e ) &#123;</div><div class="line">    alert(<span class="string">'Caught Exception: '</span> + e.description);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>浏览器对xhr json格式响应数据的支持并不全面，需特殊处理，假设服务端返回的为json数据，处理可以如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertContents</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</div><div class="line">    <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</div><div class="line">      <span class="keyword">var</span> response = <span class="built_in">JSON</span>.parse(httpRequest.responseText);</div><div class="line">      alert(response.computedString);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      alert(<span class="string">'There was a problem with the request.'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><code>XMLHttpRequest</code>类从<code>XMLHttpRequestEventTarget</code>和<code>EventTarget</code>继承</p>
<p>简单来说，一个处理http请求事件，一个可以监听事件消息，众多浏览器均以支持。</p>
<p>提供标准的<code>addEventListener()</code>APIs注册消息，然后设置<code>on*</code>属性为消息处理函数</p>
<p>因此可以看到类似以下形式的api：</p>
<ul>
<li>xhr.onload = reqListener</li>
<li>xhr.onerror =  errorHandler</li>
<li>xhr.onprogress = progressHandler</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单过了一遍XHR，总体来看依旧是典型的对象编程，对于普通使用者无非就是熟悉api，看了XHR的api，再去看ajax的api，会感觉非常容易接受，甚至自己动手写个ajax也是不难实现的。</p>
<p>资料参考<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">MDN XMLHttpRequest</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;据说前端培训班第一课就会讲&lt;code&gt;XMLHttpRequest&lt;/code&gt;和&lt;code&gt;AJAX&lt;/code&gt;。&lt;br&gt;不说别的，至少能得出结论，这是个很基础，很重要的概念。&lt;br&gt;我没去过培训班，在此总结一下，如果被问到这个问题，我会怎么回答。&lt;br&gt;
    
    </summary>
    
      <category term="common-sense" scheme="http://xu-li.cn/categories/common-sense/"/>
    
    
      <category term="XMLHttpRequest" scheme="http://xu-li.cn/tags/XMLHttpRequest/"/>
    
      <category term="AJAX" scheme="http://xu-li.cn/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>Cross-Origin</title>
    <link href="http://xu-li.cn/2017/cross-origin/"/>
    <id>http://xu-li.cn/2017/cross-origin/</id>
    <published>2017-12-25T12:50:38.000Z</published>
    <updated>2018-02-25T04:00:05.014Z</updated>
    
    <content type="html"><![CDATA[<p>前端跨域(cross-origin)是个应该掌握的基本常识，网上很多资料都有讲，全面总结下加深印象<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>跨域资源共享：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">Cross origin resource sharing(CORS)</a></p>
<p>浏览器的安全策略-同源策略: <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">same origin policy)</a></p>
<p>总结来说</p>
<p>一个源的定义：</p>
<p>如果<code>协议</code>，<code>端口</code>（如果指定了一个）和<code>域名</code>对于两个页面是相同的，则两个页面具有相同的<code>源</code></p>
<p>请求<code>非同源</code>资源的请求叫做<code>跨域 HTTP 请求</code></p>
<p>出于安全原因，浏览器限制<code>从脚本内发起的</code>跨域HTTP请求</p>
<p>具体如何限制呢？</p>
<ul>
<li>请求成功，拦截响应（大部分是这条）</li>
<li>拦截请求（例如部分浏览器不允许HTTPS跨域访问HTTP）</li>
</ul>
<p>但是！跨越请求资源的需求不可或缺，所以需要想办法绕过限制</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="AJAX中的同源限制"><a href="#AJAX中的同源限制" class="headerlink" title="AJAX中的同源限制"></a>AJAX中的同源限制</h2><p>实例示范跨域请求资源被拦截</p>
<p>打开浏览器，在console中输入以下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'https://baidu.com'</span>)</div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">&#125;</div><div class="line">xhr.send()</div></pre></td></tr></table></figure></p>
<p>可以看到请求是成功的，但是没有响应，会看到一串错误信息, 提示没有允许跨域请求头</p>
<p>原因就是XHR遵循了浏览器的同源策略</p>
<h2 id="天然跨域"><a href="#天然跨域" class="headerlink" title="天然跨域"></a>天然跨域</h2><p>然而上述场景很容易联想到另外的情况：表单提交<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span> </div><div class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>很显然这个是可以跳转成功的，类似的还有</p>
<ul>
<li><code>&lt;a&gt;</code>标签，GET请求， 会刷新或离开页面</li>
<li><code>&lt;img&gt;</code>src属性，GET请求， 加载外部图片</li>
<li><code>&lt;link&gt;</code>标签， GET请求，加载css等资源</li>
<li><code>&lt;script&gt;</code>， GET请求，加载脚本资源</li>
</ul>
<p>这些都实现了获取非同源资源的请求，为什么没有被浏览器限制呢？</p>
<p>有人称之为“天然跨越”，因为浏览器认为这些访问是安全的，从脚本内发起的资源请求则不在该范围内</p>
<h1 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h1><p>虽然有些html标签实现了“天然跨域”，但这远远不够，页面不总是静态的，如何让AJAX实现跨域请求资源呢，传统的三个方法如下：</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS 是一个 W3C 标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p>
<p>用法也很好理解，<code>响应头部</code>添加字段告诉浏览器，响应符合规范，是安全合法的，从而让浏览器不拦截响应</p>
<p>eg:</p>
<p><code>&#39;Access-Control-Allow-Origin&#39;: http://127.0.0.1:3000</code></p>
<p>字段值包括源的三个“身份值”，协议，域名，端口</p>
<p>当然这种设置只能是<code>服务器</code>去做，服务器有权决定自己的资源对谁开放</p>
<p>另外一个不太算缺点的缺点，该标准仅支持IE10 及以上</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 全称为：JSON with padding，可用于解决老版本浏览器的跨域数据访问问题。</p>
<p>用法如下：</p>
<p>前端逻辑：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// jsonp/index.html</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        alert(<span class="string">'获得 X 数据:'</span> + data.x);</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:3000?callback=jsonpCallback"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>后端用nodejs来模拟<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// jsonp/server.js</span></div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line">	</div><div class="line"><span class="built_in">require</span>(<span class="string">'http'</span>).createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">const</span> data = &#123;</div><div class="line">		<span class="attr">x</span>: <span class="number">10</span></div><div class="line">	&#125;;</div><div class="line">	<span class="comment">// 拿到回调函数名</span></div><div class="line">	<span class="keyword">const</span> callback = url.parse(req.url, <span class="literal">true</span>).query.callback;</div><div class="line">	<span class="built_in">console</span>.log(callback);</div><div class="line">	res.writeHead(<span class="number">200</span>);</div><div class="line">	res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>);</div><div class="line"></div><div class="line">&#125;).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure></p>
<p>原理：</p>
<pre><code>利用&lt;script&gt;标签src属性的天然跨越，向后端传递参数，响应返回为函数调用
</code></pre><p>这个函数是前端事先准备的（jsonpCallback），函数参数由后端提供，后端响应是<code>jsonpCallback(data)</code>, 即调用函数，实现动态交互</p>
<p>优点：</p>
<ul>
<li>不受浏览器同源策略影响</li>
<li>兼容性好</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持GET请求，原因是JSONP的实现是“借鸡下蛋”，<code>&lt;script&gt;</code>的src属性只支持GET请求方式获取资源</li>
<li>无法捕获连接异常</li>
</ul>
<h2 id="服务端代理"><a href="#服务端代理" class="headerlink" title="服务端代理"></a>服务端代理</h2><p>这种方式依然是对同源策略的一种妥协，原理是在同源域名下使用代理转发请求</p>
<p>eg:</p>
<p><code>&#39;/proxy?url=http://baidu.com&#39;</code></p>
<p>后端取得参数后自行访问目标资源，得到结果后再返回给浏览器</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端跨域(cross-origin)是个应该掌握的基本常识，网上很多资料都有讲，全面总结下加深印象&lt;br&gt;
    
    </summary>
    
      <category term="common-sense" scheme="http://xu-li.cn/categories/common-sense/"/>
    
    
      <category term="Cross-Origin" scheme="http://xu-li.cn/tags/Cross-Origin/"/>
    
      <category term="CORS" scheme="http://xu-li.cn/tags/CORS/"/>
    
      <category term="JSONP" scheme="http://xu-li.cn/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://xu-li.cn/2017/promise/"/>
    <id>http://xu-li.cn/2017/promise/</id>
    <published>2017-12-21T13:15:27.000Z</published>
    <updated>2018-03-28T14:25:30.544Z</updated>
    
    <content type="html"><![CDATA[<p>作为es6的新特性，<code>promise</code>的出现，使得<code>callback hell</code>有了优雅的解决方案，掌握promise的使用无疑是一种技能提升。本文基于《ECMAScript 6 入门》和诸多碎片化的阅读以及实践中遇到的问题做一次全面总结。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案<code>回调函数和事件</code>更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Promise对象是一个构造函数</span></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>)=&gt;</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">        res(value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        rej(error);</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>初始化实例时的参数是一个函数。</li>
<li>函数有两个参数，也均为<code>函数类型</code>，可分别在成功、失败时调用，作为对象状态改变的标志</li>
<li>调用<code>res</code>或<code>rej</code>时，最多只能传<code>一个参数</code>给后续回调函数，多个参数时后续参数不会被接收。可传递一个数组或对象解决多个参数的需求。</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Promise对象包裹了一个异步操作，对象有三种状态：<code>pending</code>（进行中）、<code>resolved</code>（已成功）和<code>rejected</code>（已失败）。对象状态是私有属性，不受外界影响，只有内部操作才能改变。</li>
<li>Promise对象初始状态为<code>pending</code>，当异步操作完成时，调用<code>res()</code>，即更改状态<code>pending -&gt; resolved</code>; 异步操作失败时，调用<code>rej()</code>，即更改状态<code>pending -&gt; rejected</code></li>
<li>有且仅有上述两种状态改变的场景，且状态一旦改变就不会再变化。</li>
<li>状态变化时按注册顺序调用回调函数，实现异步调用的同步效果</li>
<li>调用<code>res</code>或<code>rej</code>并<code>不是终结promise</code>内部代码的执行，而是发送异步事件的结果到事件循环，内部后续代码反而会先于异步执行。要实现终结效果加上<code>return</code>即可。</li>
<li>Promise实例化内部代码都是立即执行，后续处理都是回调，都会在本轮事件循环结束时才执行</li>
<li>当状态是pending时无法得知状态会如何改变，取决于异步操作结果</li>
<li>由于状态变化后无法改变且一直保持，对改变状态后的promise对象添加回调函数也会立即执行，不会像事件监听那样错过就不会再触发。</li>
<li>由于上一条的特性，多个回调函数时无法中途取消执行</li>
<li>当有内部错误，且没有注册<code>rejected</code>状态处理函数时会报错，一般建议都注册错误处理函数</li>
<li>回调函数默认返回新的Promise对象，也可以手动指定promise对象返回</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise实例生成以后，可以用继承的<code>then</code>方法分别指定resolved状态和rejected状态的回调函数。<code>then</code>方法<code>返回的是一个新的Promise实例（注意，不是原来那个Promise实例）</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>then方法在<code>调用它的Promise对象</code>的状态发生变化，才会被调用。</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数，属于语法糖范围，使代码更简洁。<br>catch有如下特点：</p>
<ul>
<li>promise对象状态变为<code>rejected</code>时调用</li>
<li><code>then</code>方法内部运行错误也能被捕获，但状态改变后再抛出错误不会被捕获</li>
<li>promise对象的错误能冒泡传递，所有catch能获取整个流程的所有错误</li>
<li>catch返回的也是新的promise对象，因此后续仍可以使用then方法，只是后续then状态变化或内部出错，不会再被之前的catch捕获</li>
<li>catch内也会报错，也会被当做一个未处理的错误，此时再之后再追加一个catch也能捕获该错误。</li>
</ul>
<p>因为catch的强大功能，所有一般不适用<code>then</code>函数的第二个参数去捕获错误，而总是使用catch</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>对象静态方法，作用是将现有对象转为Promise对象</p>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><ul>
<li><code>promise实例</code>，不做修改，直接返回</li>
<li><code>thenable</code>对象(具有then方法的对象), 会立即执行对象的then方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>参数不是具有then方法的对象，或根本就不是对象，则返回一个新的resolved状态的 Promise 对象，参数向后传递。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(s)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Hello</span></div></pre></td></tr></table></figure>
<ul>
<li>无参数。直接返回一个resolved状态的 Promise 对象</li>
<li>仍是最多只接受一个参数，多余的参数不会被传递</li>
</ul>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>类似<code>Promise.resolve()</code>, 不过返回的promise默认<code>rejected</code> 状态。</p>
<ul>
<li>仍然最多只接受一个参数</li>
<li>不同的是，传递的参数<code>都会被原封不动的向后传递</code></li>
</ul>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<ul>
<li>参数必须是有 Iterator 接口，且返回的每个成员都是 Promise 实例的类型，通常为数组，成员为Promise对象</li>
<li>参数中如果存在不是promise对象的，会调用<code>Promise.resolve</code>方法转化</li>
<li>返回值为一个新的Promise对象</li>
</ul>
<p>返回对象的状态分两种情况：</p>
<ol>
<li>只有参数中的promise对象有一个变成rejected，此时第一个被reject的实例的返回值，会传递给该对象的回调函数</li>
<li>参数所有实例状态均变为resolved，返回值对象才会改变并同步，返回值一起传递给对象的回调函数。</li>
</ol>
<p>参数中的promise对象没有自己的catch方法时，就会调用返回值对象的catch方法</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>和all方法类似，但状态变化有区别，只要有一个实例率先改变状态，返回结果的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给返回结果的回调函数。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>基于以上对Promise对象的理解，很容易联想到可以做一些扩展功能</p>
<ul>
<li><code>done()</code> - 针对catch的补充，如果catch内部出错，希望也能捕获错误，而不是后续继续增加catch</li>
<li><code>finally()</code> - 有些操作希望无论异步操作是成功还是失败都执行</li>
<li><code>try()</code> - Promise内部基本都是一个异步函数，希望能能接受一个同步函数为参数，同时能让该函数立即执行，返回值为promise</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一版done, 其实只是简单包装了catch, 将错误抛向全局。</span></div><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</div><div class="line">        process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            <span class="keyword">throw</span> err</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二版，自定义错误处理函数</span></div><div class="line"><span class="comment">//其实更加简单了，给done传递错误处理函数即可，`.done(err=&gt;console.log(err))`</span></div><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.catch(rej)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第三版，增加一个成功时执行操作，失败时错误上抛</span></div><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.then(res)</div><div class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</div><div class="line">            process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">                <span class="keyword">throw</span> err</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第四版，自定义成功或失败时的操作</span></div><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">res, rej</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.then(res, rej)</div><div class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</div><div class="line">            process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">                <span class="keyword">throw</span> err</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>finally</code>的最关键点是不能在catch之后，因为放在catch之后，失败时被catch捕获，返回新的promise对象，这时状态是无法获取到的。因此这并不是想python里那么纯粹的finally。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</div><div class="line">        f()</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value)</div><div class="line">    &#125;, err=&gt;&#123;</div><div class="line">        f()</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>try</code>最简单的实现，是在最外层再包装一个Promise，因为promise初始化过程都是立即执行的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</div><div class="line">(</div><div class="line">  <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</div><div class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> resolve(f())</div><div class="line">  )</div><div class="line">)();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</div><div class="line"><span class="comment">// now</span></div><div class="line"><span class="comment">// next</span></div></pre></td></tr></table></figure>
<p>之所以需要这么麻烦的实现这个需求，是因为很多场景下流程的第一步都是同步生成一个Promise对象，然后用then和catch控制流程，<br>然而如果在最开始生成Promise之间程序有内部错误，这个错误是不会被catch捕获到的，所有这时try的实现很有必要，将第一步同步生成Promise对象的操作包裹起来，即使出错也会被catch捕获处理。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="promise-的链式调用。"><a href="#promise-的链式调用。" class="headerlink" title="promise 的链式调用。"></a>promise 的链式调用。</h3><p>提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 <code>.then 或者 .catch 都会返回一个新的 promise</code>，从而实现了链式调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span></div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//2</span></div></pre></td></tr></table></figure>
<h3 id="promise-的-then-或者-catch-可以被调用多次"><a href="#promise-的-then-或者-catch-可以被调用多次" class="headerlink" title="promise 的 .then 或者 .catch 可以被调用多次"></a>promise 的 .then 或者 .catch 可以被调用多次</h3><p>但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</div><div class="line">    resolve(<span class="string">'success'</span>)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res)</div><div class="line">&#125;)</div><div class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//success</span></div><div class="line"><span class="comment">//success</span></div></pre></td></tr></table></figure>
<h3 id="then-或者-catch-中-return-一个-error-对象并不会抛出错误"><a href="#then-或者-catch-中-return-一个-error-对象并不会抛出错误" class="headerlink" title="then 或者 .catch 中 return 一个 error 对象并不会抛出错误"></a>then 或者 .catch 中 return 一个 error 对象并不会抛出错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="comment">// then: Error: error!!!</span></div><div class="line"><span class="comment">//     at Promise.resolve.then (...)</span></div><div class="line"><span class="comment">//     at ...</span></div></pre></td></tr></table></figure>
<p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象<br>即 <code>return new Error(&#39;error!!!&#39;)</code></p>
<p>等价于<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code></p>
<p>传递错误的方式有</p>
<ul>
<li><code>return Promise.reject(new Error(&#39;error!!!&#39;))</code></li>
<li><code>throw new Error(&#39;error!!!&#39;)</code></li>
</ul>
<h3 id="then-或-catch-返回的值不能是-promise-本身，否则会造成死循环。"><a href="#then-或-catch-返回的值不能是-promise-本身，否则会造成死循环。" class="headerlink" title=".then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。"></a>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> promise</div><div class="line">  &#125;)</div><div class="line"><span class="comment">//TypeError</span></div></pre></td></tr></table></figure>
<h3 id="then-或者-catch-的参数期望是函数，传入非函数则会发生值穿透"><a href="#then-或者-catch-的参数期望是函数，传入非函数则会发生值穿透" class="headerlink" title=".then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透"></a>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">  .then(<span class="number">2</span>)</div><div class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</div><div class="line">  .then(<span class="built_in">console</span>.log)</div><div class="line"><span class="comment">//1</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为es6的新特性，&lt;code&gt;promise&lt;/code&gt;的出现，使得&lt;code&gt;callback hell&lt;/code&gt;有了优雅的解决方案，掌握promise的使用无疑是一种技能提升。本文基于《ECMAScript 6 入门》和诸多碎片化的阅读以及实践中遇到的问题做一次全面总结。&lt;br&gt;
    
    </summary>
    
      <category term="Promise" scheme="http://xu-li.cn/categories/Promise/"/>
    
    
      <category term="javaScript" scheme="http://xu-li.cn/tags/javaScript/"/>
    
      <category term="promise" scheme="http://xu-li.cn/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Mongoose入门总结</title>
    <link href="http://xu-li.cn/2017/mongoose/"/>
    <id>http://xu-li.cn/2017/mongoose/</id>
    <published>2017-11-15T10:57:38.000Z</published>
    <updated>2017-11-15T11:36:54.867Z</updated>
    
    <content type="html"><![CDATA[<p>Mongoose 是一个基于Node.js的MongoDB接口ORM类库，也被称为ODM库。那些高大上的解释就不贴了。我的理解是mongoDB将数据库抽象成文档类型，而mongoose将文档映射到js对象上，让使用者可以使用js对象来操作文档从而实现对数据的增改删查，因此称之为Object Document Model。<br><a id="more"></a></p>
<h2 id="连接数据库-Connection"><a href="#连接数据库-Connection" class="headerlink" title="连接数据库-Connection"></a>连接数据库-Connection</h2><p>使用数据库之前肯定需要连接上数据库先，Mongoose的API提供了两种方式<code>mongoose.createConnection</code>和<code>mongoose.connect</code>。文档说前者可以连接多个数据库，后者使用默认连接，老实说这个解释没能让我明白区别，还是看源代码吧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mongoose</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.connections = [];</div><div class="line">  <span class="keyword">this</span>.models = &#123;&#125;;</div><div class="line">  <span class="keyword">this</span>.modelSchemas = &#123;&#125;;</div><div class="line">  <span class="comment">/* default global options */</span></div><div class="line">  <span class="keyword">this</span>.options = &#123;</div><div class="line">    <span class="attr">pluralization</span>: <span class="literal">true</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> conn = <span class="keyword">this</span>.createConnection(); <span class="comment">/* default connection */</span></div><div class="line">  conn.models = <span class="keyword">this</span>.models;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> mongoose = <span class="built_in">module</span>.exports = exports = <span class="keyword">new</span> Mongoose;</div></pre></td></tr></table></figure></p>
<p>可以看出来，我们引用mongoose时，就是引用Mongoose的一个实例。<br>构造函数格外的简洁，初始化四个属性，建立一个连接，再将该连接的models属性指向实例的同名属性。<br>下面再来看建立的这个连接<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> driver = global.MONGOOSE_DRIVER_PATH || <span class="string">'./drivers/node-mongodb-native'</span>;</div><div class="line"><span class="keyword">var</span> Connection = <span class="built_in">require</span>(driver + <span class="string">'/connection'</span>);</div><div class="line"></div><div class="line">Mongoose.prototype.createConnection = <span class="function"><span class="keyword">function</span>(<span class="params">uri, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> conn = <span class="keyword">new</span> Connection(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.connections.push(conn);</div><div class="line">  <span class="keyword">if</span> (options &amp;&amp; options.useMongoClient) &#123;</div><div class="line">    <span class="keyword">return</span> conn.openUri(uri, options);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> conn;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mongoose.prototype.__defineGetter__(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.connections[<span class="number">0</span>];</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Mongoose.prototype.__defineSetter__(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.connections[<span class="number">0</span>] = v;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Mongoose初始化实例即建立了和MongoDB的连接，也就是注释了说的默认连接，可以通过<code>mongoose.connection</code>访问，该连接可后续再行初始化。</p>
<p>到这里就可以进入正题说<code>mongoose.createConnection</code>和<code>mongoose.connect</code>的区别了。贴下connect的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Mongoose.prototype.connect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> conn = <span class="keyword">this</span>.connection;</div><div class="line">  <span class="keyword">if</span> ((<span class="built_in">arguments</span>.length === <span class="number">2</span> || <span class="built_in">arguments</span>.length === <span class="number">3</span>) &amp;&amp;</div><div class="line">      <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">'string'</span> &amp;&amp;</div><div class="line">      <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>] === <span class="string">'object'</span> &amp;&amp;</div><div class="line">      <span class="built_in">arguments</span>[<span class="number">1</span>].useMongoClient === <span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">return</span> conn.openUri(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (rgxReplSet.test(<span class="built_in">arguments</span>[<span class="number">0</span>]) || checkReplicaSetInUri(<span class="built_in">arguments</span>[<span class="number">0</span>])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MongooseThenable(<span class="keyword">this</span>, conn.openSet.apply(conn, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MongooseThenable(<span class="keyword">this</span>, conn.open.apply(conn, <span class="built_in">arguments</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>connect就是直接使用mongoose初始化时建立的那个连接去连接数据库，具体怎么连接数据库，根据参数选择，可以有<code>openUri</code>、<code>openSet</code>和<code>open</code>, 4.x版本推荐第一种方式，后两种将被废弃。即需形如<code>mongoose.connect(db_url, {useMongoClient:true})</code>这种方式。<br>而<code>createConnection</code>则是mongoose初始化选择的连接方式，可以建立多个连接，每个连接都会被push到<code>mongoose.connections</code>数组中，同时返回此次建立的连接，如果指定了参数，且符合要求，则调用<code>openUri(uri, options)</code>连接数据库。<br>至此，基本捋清二者关系了。</p>
<p>小结下就是，mongoose初始化时会先建立一个与MongoDB驱动的默认连接，connect的方式就是使用该连接。createConnection 会再继续建立与驱动的连接，这种方式适合操作多个数据库的操作。使用openUri方法，是给驱动传参连接数据库。</p>
<p>下面举例以上的说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</div><div class="line">mongoose.Promise = global.Promise</div><div class="line"><span class="keyword">var</span> url = process.env.MONGO_URL || <span class="string">'mongodb://localhost:27017/admin'</span></div><div class="line"></div><div class="line"><span class="comment">/* 使用默认连接传参连接数据库 */</span></div><div class="line">mongoose.connection.openUri(url, (err, conn)=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(conn.db.databaseName)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">/* 使用默认连接传参连接数据库 */</span></div><div class="line"><span class="keyword">var</span> db = mongoose.connect(url, &#123;<span class="attr">useMongoClient</span>:<span class="literal">true</span>&#125;)</div><div class="line"><span class="built_in">console</span>.log(mongoose.connections.length)</div><div class="line"></div><div class="line"><span class="comment">/* 重新建立连接并传参连接数据库 */</span></div><div class="line"><span class="keyword">var</span> db1 = mongoose.createConnection(url, &#123;<span class="attr">useMongoClient</span>:<span class="literal">true</span>&#125;)</div><div class="line"><span class="built_in">console</span>.log(mongoose.connections.length)</div></pre></td></tr></table></figure></p>
<h2 id="定义文档结构-Schema"><a href="#定义文档结构-Schema" class="headerlink" title="定义文档结构-Schema"></a>定义文档结构-Schema</h2><p>mongoDB的collection对应关系型数据库的table，collection是文档的集合，mongoose里的<code>Schema</code>就是用来定义文档的数据结构。<br>支持的数据类型称为<code>SchemaTypes</code>，分别是</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Boolean</li>
<li>Array</li>
<li>Buffer</li>
<li>ObjectId</li>
<li>Mixed</li>
</ul>
<p>使用举例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</div><div class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</div><div class="line"></div><div class="line"><span class="keyword">var</span> blogSchema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">  <span class="attr">title</span>:  &#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">index</span>: <span class="literal">true</span>&#125;,</div><div class="line">  <span class="attr">author</span>: <span class="built_in">String</span>,</div><div class="line">  <span class="attr">body</span>:   <span class="built_in">String</span>,</div><div class="line">  <span class="attr">comments</span>: [&#123; <span class="attr">body</span>: <span class="built_in">String</span>, <span class="attr">date</span>: <span class="built_in">Date</span> &#125;],</div><div class="line">  <span class="attr">date</span>: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now &#125;,</div><div class="line">  <span class="attr">hidden</span>: <span class="built_in">Boolean</span>,</div><div class="line">  <span class="attr">meta</span>: &#123;</div><div class="line">    <span class="attr">votes</span>: <span class="built_in">Number</span>,</div><div class="line">    <span class="attr">fans</span>:  <span class="built_in">Number</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>除了定义文档结构，Schema还能定义文档实例方法，模型的静态方法，混合索引，虚拟属性，以及一些和文档生命周期有关的钩子。此处先不展开。</p>
<h2 id="数据库模型-Model"><a href="#数据库模型-Model" class="headerlink" title="数据库模型-Model"></a>数据库模型-Model</h2><p>定义Schema后，需要将它编译成Model。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">name</span>: <span class="string">'string'</span>, <span class="attr">size</span>: <span class="string">'string'</span> &#125;);</div><div class="line"><span class="keyword">var</span> Tank = mongoose.model(<span class="string">'Tank'</span>, schema);</div></pre></td></tr></table></figure></p>
<p>Model是文档的构造函数，Model的实例即文档。<br>实例化方法有两种：</p>
<ul>
<li>new 之后生成的实例使用save方法保存</li>
<li>使用类方法create创建</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Tank = mongoose.model(modelName, yourSchema);</div><div class="line"></div><div class="line"><span class="keyword">var</span> small = <span class="keyword">new</span> Tank(&#123; <span class="attr">size</span>: <span class="string">'small'</span> &#125;);</div><div class="line">small.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</div><div class="line">  <span class="comment">// saved!</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line">Tank.create(&#123; <span class="attr">size</span>: <span class="string">'small'</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, small</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</div><div class="line">  <span class="comment">// saved!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>需要特别说明的是：</p>
<ul>
<li>model的操作不会生效，直到与数据库的连接完成。这里也是异步没有出错的原因。</li>
<li>如果使用默认连接需使用<code>mongoose.model()</code>，如果是自定义连接使用<code>connection&#39;s model()</code>，这是个挂载位置问题。</li>
</ul>
<p>具体的model实例对应一个<code>collection</code>,collection是文档的集合，每一个具体的文档对应一张数据表，可以映射为一个javascript对象。其链式关系大体为</p>
<ul>
<li>db -&gt; collections</li>
<li>collection -&gt; docs</li>
<li>doc -&gt; js Object (mongoose.Document instance)</li>
</ul>
<h2 id="数据库操作-CRUD"><a href="#数据库操作-CRUD" class="headerlink" title="数据库操作-CRUD"></a>数据库操作-CRUD</h2><p>每个数据库都会有增改删查的操作，对应mongodb而言，操作的主要分两类</p>
<ul>
<li>collection 层的批量操作</li>
<li>doc 层的具体操作<br>如果是第一类操作，所有方法都是基于model的，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">model.create() <span class="comment">//给该collection创建一个或多个新的doc</span></div><div class="line">model.remove() <span class="comment">//删除一个或多个符合条件的doc</span></div><div class="line">model.find()   <span class="comment">//查找，返回一个docs数组</span></div><div class="line">model.update() <span class="comment">//更新一个或多个doc</span></div><div class="line">model.count() <span class="comment">//统计该collection下docs的数量</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果是基于单个doc的操作，一些常用的方法有<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">doc.remove() <span class="comment">//删除该文档</span></div><div class="line">doc.save() <span class="comment">//更改后的保存</span></div><div class="line">doc.update() <span class="comment">//更新</span></div><div class="line">doc.toObject() <span class="comment">//将文档转为纯javascript对象，转化后就不再有save等方法</span></div><div class="line">doc.id  <span class="comment">//获取文档元素</span></div></pre></td></tr></table></figure></p>
<p>不同的操作层级有类似的操作方法，但是作用的对象不同，逻辑上需辨别清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一切的数据库操作都是建立在与数据库的连接上，所有文章开头详细描述了mongoose对于与mongodb连接的管理</li>
<li>schema和model的意义及使用</li>
<li>数据库操作可以理解为是先获取对应的对象，随后调用对应的操作方法</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mongoose 是一个基于Node.js的MongoDB接口ORM类库，也被称为ODM库。那些高大上的解释就不贴了。我的理解是mongoDB将数据库抽象成文档类型，而mongoose将文档映射到js对象上，让使用者可以使用js对象来操作文档从而实现对数据的增改删查，因此称之为Object Document Model。&lt;br&gt;
    
    </summary>
    
      <category term="mongoose" scheme="http://xu-li.cn/categories/mongoose/"/>
    
    
      <category term="mongoose" scheme="http://xu-li.cn/tags/mongoose/"/>
    
      <category term="mongodb" scheme="http://xu-li.cn/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>shell script</title>
    <link href="http://xu-li.cn/2017/shell/"/>
    <id>http://xu-li.cn/2017/shell/</id>
    <published>2017-11-05T10:57:38.000Z</published>
    <updated>2017-11-11T12:17:08.952Z</updated>
    
    <content type="html"><![CDATA[<p>总结shell脚本<br><a id="more"></a></p>
<h2 id="shell-VS-shell-script"><a href="#shell-VS-shell-script" class="headerlink" title="shell VS shell script"></a>shell VS shell script</h2><p>shell 是一种应用程序，负责将指令传达至linux内核。<code>terminl</code> 是一种输入输出的虚拟终端，本身并不会解析输入的命令，真正处理输入命令的是shell。<br><code>shell script</code> 是为shell编写的脚本，本质是命令的集合，相对terminal输入的方式，shell脚本可以批量操作，可以有组合逻辑，能做的事更多，但需要符合一定的代码规范。学习shell脚本本质是掌握shell命令以及shell script的语法规则。本文着重总结后者。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>脚本第一行需是约定的声明， 例如：<code>#!/bin/bash</code>，作用是告诉系统用那种解释器，全常用的是bash，很多系统自带，当然也可定义其他版本shell。</p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><ol>
<li>添加执行权限 <code>chmod +x filepath</code></li>
<li>执行脚本     <code>filepath arg1 arg2 arg3 ...</code></li>
</ol>
<h2 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h2><ul>
<li><code>$0</code> :   当前脚本文件名</li>
<li>$n  :  传递给脚本或函数的参数，n是一个数字，表示第几个参数，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数 …</li>
<li><code>$#</code> :   传递给脚本或函数的参数个数</li>
<li><code>$*</code> :   传递给脚本或函数的所有参数，当它被双引号（” “）包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数</li>
<li><code>$@</code>:    传递给脚本或函数的所有参数，当它被双引号（” “）包含时，与<code>$*</code>稍有不同，”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数, <code>$*</code> 和<code>$@</code>不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数</li>
<li><code>$$</code>: 脚本运行的当前进程ID号</li>
<li><code>$?</code>: 上一个命令的退出状态，<code>或函数的返回值</code>，如果正常退出则返回0，反之为非0值</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>脚本里常用数据类型分为三类，字符串、数字类型，数组。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果不声明类型，默认为字符串。<br>赋值时<code>=</code>附近不能有空格（<code>shell中使用空格会带来很多诸如此类的问题，能不用就不用！</code>）<br>使用变量是时需再变量名前加上<code>$</code>,同时使用可选的<code>{}</code>表示变量边界<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=8</div><div class="line">b=9</div><div class="line"><span class="built_in">echo</span> <span class="variable">$a</span>     <span class="comment"># $&#123;a&#125;</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$a</span>+<span class="variable">$b</span>  <span class="comment"># 8+9 默认字符串，并不是整型</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#a&#125;</span>  <span class="comment"># 获取字符串长度</span></div></pre></td></tr></table></figure></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>直接连接，中间不能有空格<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=hello</div><div class="line">b=<span class="variable">$a</span><span class="string">" world"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$b</span></div></pre></td></tr></table></figure></p>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="${} 高级用法"></a>${} 高级用法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">file=/dir1/dir2/dir3/my.file.txt</div><div class="line"><span class="comment">#可以用$&#123; &#125;分别替换获得不同的值：</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file#*/&#125;</span>   <span class="comment">#拿掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file##*/&#125;</span>  <span class="comment">#拿掉最后一个 / 及其左边的字符串：my.file.txt</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file#*.&#125;</span>   <span class="comment">#拿掉第一个 . 及其左边的字符串：file.txt</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file##*.&#125;</span>  <span class="comment">#拿掉最后一个 . 及其左边的字符串：txt</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file%/*&#125;</span>   <span class="comment">#拿掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file%%/*&#125;</span>  <span class="comment">#拿掉第一个 / 及其右边的字符串：(空值)</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file%.*&#125;</span>   <span class="comment">#拿掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file%%.*&#125;</span>  <span class="comment">#拿掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my</span></div><div class="line"><span class="comment"># `#` 去掉左边</span></div><div class="line"><span class="comment"># `%` 去掉右边</span></div><div class="line"><span class="comment"># 单一符号是最小匹配，两个符号是最大匹配。</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file:0:5&#125;</span>  <span class="comment">#提取最左边的 5 个字节：/dir1</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file:5:5&#125;</span>  <span class="comment">#提取第 5 个字节右边的连续 5 个字节：/dir2</span></div><div class="line"><span class="comment">#也可以对变量值里的字符串作替换：</span></div><div class="line"><span class="variable">$&#123;file/dir/path&#125;</span>  <span class="comment">#将第一个 dir 替换为 path：/path1/dir2/dir3/my.file.txt</span></div><div class="line"><span class="variable">$&#123;file//dir/path&#125;</span> <span class="comment">#将全部 dir 替换为 path：/path1/path2/path3/my.file.txt</span></div></pre></td></tr></table></figure>
<p>变量可用<code>declare</code>关键字声明类型，但也可不用。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="comment">#通过下标声明</span></div><div class="line">array[0]=a</div><div class="line">array[1]=b</div><div class="line"><span class="comment">#或声明并统一赋值</span></div><div class="line">array=(a,b,c)</div><div class="line"><span class="comment">#取数组中的值：</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;data[1]&#125;</span>   <span class="comment"># 输出第1个元素</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;data&#125;</span>      <span class="comment"># 不写默认是第0个</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;data[*]&#125;</span>   <span class="comment"># 输出数组中所有的变量</span></div><div class="line"><span class="comment"># 取得数组元素的个数</span></div><div class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></div><div class="line"><span class="comment"># 或者</span></div><div class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></div><div class="line"><span class="comment"># 取得数组单个元素的长度</span></div><div class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></div></pre></td></tr></table></figure>
<h2 id="单双引号及反引号"><a href="#单双引号及反引号" class="headerlink" title="单双引号及反引号"></a>单双引号及反引号</h2><p>字符串可以用单引号，也可以用双引号，也可以<code>不用引号</code>（默认字符串类型）。<br>单双引号的区别：</p>
<ul>
<li>单引号里<code>任何字符</code>都会原样输出，内部变量无效</li>
<li>单引号内部不能再出现单引号（转义输出也不行）</li>
<li>双引号里可以有变量（相当于模板字符串）</li>
<li>双引号可以出现转义字符</li>
</ul>
<p>反引号”`”,用于命令替换(command subsitution)，执行引号内命令，返回结果填充<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#显示上周日的日期</span></div><div class="line"><span class="built_in">echo</span> the last sunday is `date <span class="_">-d</span> <span class="string">"last sunday"</span> +%Y-%m-%d`</div><div class="line"><span class="built_in">echo</span> the last sunday is $(date <span class="_">-d</span> <span class="string">"last sunday"</span> +%Y-%m-%d)</div></pre></td></tr></table></figure></p>
<p>反引号移植性好，新的shell可使用<code>$()</code>，<br>区别之一:</p>
<ul>
<li>反引号本身就对\进行了转义，保留了它本身意思，如果我们想在反引号中起到\的特殊意义，我们必须使用2个\来进行表示。<br>所以我们可以简单的想象成反引号中: <code>\\ = \</code></li>
<li>$()中则不需要考虑\的问题，与我们平常使用的一样: <code>\ = \</code><br>示例如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#eg:my host name is 'sora'</span></div><div class="line"><span class="built_in">echo</span>  `<span class="built_in">echo</span> <span class="variable">$HOSTNAME</span>`   <span class="comment"># sora</span></div><div class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$HOSTNAME</span>)   <span class="comment"># sora 此时二者无区别</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span>  `<span class="built_in">echo</span> \<span class="variable">$HOSTNAME</span>`   <span class="comment"># sora</span></div><div class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> \<span class="variable">$HOSTNAME</span>)   <span class="comment"># $HOSTNAME</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span>  `<span class="built_in">echo</span> \\<span class="variable">$HOSTNAME</span>`  <span class="comment"># $HOSTNAME</span></div><div class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> \\<span class="variable">$HOSTNAME</span>)  <span class="comment"># \sora</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="echo与printf"><a href="#echo与printf" class="headerlink" title="echo与printf"></a>echo与printf</h2><p><code>echo</code> 用于字符串的输出<br><code>echo string</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 转义输出</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"\"It is a test\""</span>  </div><div class="line"><span class="comment"># 读取一行输出，read命令会去除首尾空格</span></div><div class="line"><span class="built_in">read</span> name </div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> It is a test"</span></div><div class="line"></div><div class="line"><span class="comment"># -e 开启特殊符号转义</span></div><div class="line"><span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"OK! \n"</span> <span class="comment"># 显示换行</span></div><div class="line"><span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"OK! \c"</span> <span class="comment"># 不换行</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"test"</span></div><div class="line"><span class="comment"># 显示结果定向至文件</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span> &gt; myfile</div></pre></td></tr></table></figure></p>
<p><code>printf</code> 类似于c的用法，用于格式化字符串，标准定义，移植性更好<br><code>printf  format-string  [arguments...]</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># format-string为双引号</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></div><div class="line"></div><div class="line"><span class="comment"># 单引号与双引号效果一样 </span></div><div class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span> </div><div class="line"></div><div class="line"><span class="comment"># 没有引号也可以输出</span></div><div class="line"><span class="built_in">printf</span> %s abc def</div><div class="line"></div><div class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</div></pre></td></tr></table></figure></p>
<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># declare -i 变量名声明为数值型进行运算</span></div><div class="line">a=1</div><div class="line">b=2</div><div class="line"><span class="built_in">declare</span> -i c=<span class="variable">$a</span>+<span class="variable">$b</span></div><div class="line"></div><div class="line"><span class="comment"># expr或let数值运算工具</span></div><div class="line">a=1</div><div class="line">b=2</div><div class="line">c=$(expr <span class="variable">$a</span> + <span class="variable">$b</span>)  <span class="comment"># + 号左右两侧必须有空格</span></div><div class="line"></div><div class="line"><span class="comment"># $((运算式))或 $[运算式]</span></div><div class="line">a=1 </div><div class="line">b=2</div><div class="line">c=$((<span class="variable">$a</span> + <span class="variable">$b</span>))</div><div class="line">d=$[<span class="variable">$a</span> + <span class="variable">$b</span>]</div></pre></td></tr></table></figure>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">command</span>1</div><div class="line"><span class="keyword">elif</span> condition2 </div><div class="line"><span class="keyword">then</span> </div><div class="line">    <span class="built_in">command</span>2</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">command</span>N</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># 写成一行需要分号分隔</span></div><div class="line"><span class="keyword">if</span> condition1; <span class="keyword">then</span> <span class="built_in">command</span>; <span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">command</span>1</div><div class="line">    <span class="built_in">command</span>2</div><div class="line">    ...</div><div class="line">    <span class="built_in">command</span>N</div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="comment"># 写成一行</span></div><div class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> <span class="built_in">command</span>1; <span class="built_in">command</span>2… <span class="keyword">done</span>;</div><div class="line"></div><div class="line"><span class="comment"># example</span></div><div class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value is: <span class="variable">$loop</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> condition</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">command</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="comment"># example，当int小于5时输出显示</span></div><div class="line">int=1</div><div class="line"><span class="keyword">while</span> [ <span class="variable">$int</span> <span class="_">-lt</span> 5 ]</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></div><div class="line">    int=$[<span class="variable">$int</span>+1]</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>常用的两种方式，<code>test</code>命令或<code>[]</code><br>其中用<code>[]</code>时，开头和结尾必须有空格<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">bit=`getconf LONG_BIT`</div><div class="line"><span class="comment"># 判断系统位数是否为64</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$bit</span> = 64 ] <span class="comment"># 注意前后空格, = 在判断相等时前后可以有空格，赋值时不行</span></div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'yes'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'no'</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># test命令的方式则是</span></div><div class="line"><span class="comment"># if test $bit = 64</span></div></pre></td></tr></table></figure></p>
<h3 id="整型数值比较"><a href="#整型数值比较" class="headerlink" title="整型数值比较"></a>整型数值比较</h3><ul>
<li>-eq    等于则为真</li>
<li>-ne    不等于则为真</li>
<li>-gt    大于则为真</li>
<li>-ge    大于等于则为真</li>
<li>-lt    小于则为真</li>
<li>-le    小于等于则为真<br>注意， 这些符合判断仅适用于整型<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=123</div><div class="line">b=45</div><div class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[a] <span class="_">-gt</span> $[b] <span class="comment"># 也可以用 `=` 判断</span></div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'yes'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'no'</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><p><code>operator string</code><br>字符串相等，用<code>=</code>判断, 整型的判断在这里不适用,<code>除非字符串是整型数字</code></p>
<ul>
<li>=        字符串等于则为真</li>
<li>!=    字符串不相等则为真</li>
<li>-z    字符串的长度为零则为真</li>
<li>-n     字符串的长度不为零则为真<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=<span class="string">''</span></div><div class="line"><span class="keyword">if</span> <span class="built_in">test</span> -z <span class="variable">$a</span> <span class="comment"># [ -z $a ]</span></div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'yes'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'no'</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件名判断"><a href="#文件名判断" class="headerlink" title="文件名判断"></a>文件名判断</h3><p><code>operator filename</code></p>
<ul>
<li>-a或-e 如果文件存在则为真</li>
<li>-d     如果文件存在且为目录则为真</li>
<li>-f     如果文件存在且为普通文件则为真</li>
<li>-r     如果文件存在且可读则为真</li>
<li>-s     如果文件存在且至少有一个字符则为真</li>
<li>-w     如果文件存在且可写则为真</li>
<li>-x     如果文件存在且可执行则为真</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>||    Or</li>
<li>&amp;&amp;    And<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3></li>
<li>-a   与</li>
<li>-o   或</li>
<li>!    非<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">cd</span> /bin</div><div class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="_">-e</span> ./notFile -o <span class="_">-e</span> ./bash</div><div class="line"><span class="comment"># 用逻辑运算符写如下：</span></div><div class="line"><span class="comment"># if test -e ./notFile || test -e ./bash</span></div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'有一个文件存在!'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'两个文件都不存在'</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>必须先声明再调用</p>
<h3 id="函数声明与调用"><a href="#函数声明与调用" class="headerlink" title="函数声明与调用"></a>函数声明与调用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 声明 关键字function可省略</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">funcName</span></span>()&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"><span class="comment"># 调用</span></div><div class="line">func arg1 arg2 ...</div></pre></td></tr></table></figure>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数内部$n 表示传入的第n个参数,这里和脚本参数类似</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟<code>数值</code>(0-255)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> 123</div><div class="line">&#125;</div><div class="line"><span class="built_in">test</span></div><div class="line">a=<span class="string">"$?"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$a</span></div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="得到当前脚本目录"><a href="#得到当前脚本目录" class="headerlink" title="得到当前脚本目录"></a>得到当前脚本目录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">dir=<span class="string">"cd `dirname <span class="variable">$0</span>`; pwd"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$dir</span></div></pre></td></tr></table></figure>
<h3 id="判断由当前脚本启动的实例个数"><a href="#判断由当前脚本启动的实例个数" class="headerlink" title="判断由当前脚本启动的实例个数"></a>判断由当前脚本启动的实例个数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ret=`ps -ef | grep <span class="string">"yourprocessname"</span> | grep -v grep | grep -v <span class="string">"<span class="variable">$(basename $0)</span>"</span> | wc <span class="_">-l</span>`</div><div class="line"><span class="built_in">echo</span> <span class="variable">$ret</span></div></pre></td></tr></table></figure>
<h3 id="嵌入文本-here-document"><a href="#嵌入文本-here-document" class="headerlink" title="嵌入文本(here document)"></a>嵌入文本(here document)</h3><p>将两个<code>delimiter</code>之间的内容作为输入传递给command<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">command</span> &lt;&lt; delimiter</div><div class="line">    document</div><div class="line">delimiter</div></pre></td></tr></table></figure></p>
<p>tips：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#示例</span></div><div class="line">cat &lt;&lt;EOF</div><div class="line">content to <span class="built_in">print</span></div><div class="line">EOF</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结shell脚本&lt;br&gt;
    
    </summary>
    
      <category term="shell" scheme="http://xu-li.cn/categories/shell/"/>
    
    
      <category term="shell-script" scheme="http://xu-li.cn/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>js中的this、bind、call、apply</title>
    <link href="http://xu-li.cn/2017/js-this/"/>
    <id>http://xu-li.cn/2017/js-this/</id>
    <published>2017-10-11T12:30:38.000Z</published>
    <updated>2017-10-12T12:00:05.547Z</updated>
    
    <content type="html"><![CDATA[<p>发现一个很有意思的现象，js中的<code>this</code>、<code>bind</code>、<code>call</code>、<code>apply</code>单独拿出来都知道用法，但只要两个的组合出现时就有点蒙，三个的组合出现时开始怀疑自己是否还没入门……</p>
<p>我想大概原因还是没有认真做过总结吧，之前已经总结过一次js中this的用法，不过那次是着重总结箭头函数中的this。这次把这几个经常见到的整合在一起再总结一次。<br><a id="more"></a></p>
<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><ul>
<li>this，指向一个对象，不同情况下不同, 如果是函数调用，this指向函数运行时的context，即上下文对象</li>
<li>bind，函数方法，调用后返回一个创建的新函数，第一个参数为传递给创建函数的this变量，后续参数为创建函数参数，会先于调用函数参数传入</li>
<li>call，函数方法，调用后执行该函数，第一个参数为传递给该函数的this变量，后续参数为函数参数</li>
<li>apply，函数方法，调用后执行该函数，第一个参数为传递给该函数的this变量，第二个参数可省略，但存在的话必须为一个数组或类数组</li>
</ul>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>现在随手一搜关键字<code>js</code>, <code>this</code>, 能找到无数介绍资料，很多人总结的都很好，很详尽，我也来一份我自己的总结。</p>
<h2 id="this出现的位置"><a href="#this出现的位置" class="headerlink" title="this出现的位置"></a>this出现的位置</h2><p>一般this都是出现在函数内部，但在函数外也是可以的，例如:</p>
<ul>
<li><p>在浏览器的console里敲</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span> === <span class="built_in">window</span> <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p>在nodejs脚本里写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === exports) <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//&#123;&#125;</span></div><div class="line"></div><div class="line">a = <span class="number">8</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === global)  <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)  <span class="comment">//8</span></div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure>
</li>
<li><p>但strict 模式下脚本结果会有不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//undefined</span></div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure>
</li>
<li><p>在node REPL模式下输入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global) <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>在普通函数内部，this默认指向全局变量，浏览器里对应就是<code>window</code>，node中为<code>global</code>。strict模式下则强制指向<code>undefined</code>。<br>但函数作为<code>构造函数</code>或<code>对象方法</code>时情况则不同。但都符合一个原则，统统指向函数执行时的上下文对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Test(<span class="string">'test'</span>)</div><div class="line"><span class="built_in">console</span>.log(test.name) <span class="comment">//test</span></div><div class="line"></div><div class="line"><span class="comment">//对象方法</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'test'</span>,</div><div class="line">    <span class="attr">test</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.test() <span class="comment">//test</span></div></pre></td></tr></table></figure></p>
<p>构造函数和对象方法的上下文对象都很清楚，就是调用函数的对象。<br>这里再复习下箭头函数，如果是箭头函数的调用呢<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>对于箭头函数，它没有自己的上下文，依赖于父上下文，即向外最近的this指向就是它的指向，那这里就相当与在脚本里直接打印this了，结果为<code>{}</code>,指向<code>exports</code>包对象本身，如果是浏览器则是<code>window</code>对象。</p>
<h2 id="函数内部的函数this"><a href="#函数内部的函数this" class="headerlink" title="函数内部的函数this"></a>函数内部的函数this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">name = <span class="string">'你猜'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span>.foo =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'#'</span>+<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    bar()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Test(<span class="string">'test'</span>)  <span class="comment">//#你猜</span></div><div class="line"><span class="built_in">console</span>.log(test.name)  <span class="comment">// test</span></div><div class="line"><span class="built_in">console</span>.log(test.foo()) <span class="comment">// test</span></div></pre></td></tr></table></figure>
<p>以上代码结果会是什么呢？<br>涉及的三个函数Test，bar和foo，它们内的this是同一对象么？<br>答案是否定的，非匿名函数的this指向都是独立的，情况和之前说的一样，作为普通函数和构造函数及对象方法是不一样的。</p>
<h1 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>call和apply区别只是第二个参数不同，放在一起说。<br>之前说this在函数中的指向虽然不总是一致，但也是有规律的，例如定义一个对象，那么它的方法函数内部的this，一般情况下都是指向它本身的，没有什么问题。还是之前的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'test'</span>,</div><div class="line">    <span class="attr">test</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.test() <span class="comment">// test</span></div></pre></td></tr></table></figure></p>
<p>但这是新定义了一个对象，也想使用test方法呢？你会想到直接赋值不就可以了么，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name = <span class="string">'你猜'</span></div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>:<span class="string">'foo'</span>&#125;</div><div class="line">foo.test = obj.test</div><div class="line">foo.test()</div></pre></td></tr></table></figure></p>
<p>结果行不行呢？哈哈，你猜？<br>答案是可以滴！属性赋值，函数没有立即执行，运行中的上下文是可以改变的，当调用<code>foo.test()</code>时，函数的this会指向foo对象的。<br>但注意如果是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test= obj.test</div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>这样的话test又回归一个普通函数了，this的则指向全局变量。</p>
<p>相比较而言，call和apply提供了较为简洁的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name = <span class="string">'你猜'</span></div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>:<span class="string">'foo'</span>&#125;</div><div class="line">obj.test.apply(foo)</div></pre></td></tr></table></figure></p>
<p>即手动指定函数内部的上下文，让不确定变得确定。<br>这样做的好处是什么呢，会发现call和apply实现了js中的所有对象的方法共享，即对象方法不再只限定为该对象自身调用，其他任何对象都可以通过传递this的方式改变函数执行时的上下文从而实现一处定义，多处调用。</p>
<h2 id="this语法糖"><a href="#this语法糖" class="headerlink" title="this语法糖"></a>this语法糖</h2><p>到这里几乎把函数调用的方式都举例了，总的来说就三种：</p>
<ul>
<li>func()</li>
<li>obj.func()</li>
<li><p>func.call() || func.apply()<br>通常使用的都前两种，然而事实是前两种都是以第三种调用模式实现的语法糖，本质还是第三种调用，这样做只为让语法更简洁。</p>
<p>  因此func() 等价于 func.call(this)，obj.func() 等价于 obj.func.call(obj)</p>
</li>
</ul>
<p>this即传入的上下文对象，隐式情况下会有之前所提到的种种默认值，显示情况则可以手动指定</p>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><h2 id="永久改变this指向"><a href="#永久改变this指向" class="headerlink" title="永久改变this指向"></a>永久改变this指向</h2><p>bind和call及apply类似，也可以动态修改函数执行的上下文，但又有不同，如果说call和apply是“借尸还魂”，那么bind就是“影分身”了，它创建新函数，产生独立的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'test'</span>,</div><div class="line">    <span class="attr">test</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test =  obj.test</div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>这是刚才的一个例子，结果肯定不是’test’，原因之前解释了，复制语句让test变成一个普通函数，运行时上下文对象会指向全局变量。<br>当然可以使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test.apply(obj)</div></pre></td></tr></table></figure></p>
<p>这样的方法动态修改上下文指向。但bind可以提供永久改变上下文的方法，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test =  obj.test.bind(obj)</div><div class="line">test() <span class="comment">// test</span></div></pre></td></tr></table></figure></p>
<p>这个时候test函数的this指向就固定了，指向obj。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test =  obj.test.bind(obj)</div><div class="line">test()  <span class="comment">//test</span></div><div class="line">test.apply(&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125;) <span class="comment">// test，apply传入的this未生效</span></div><div class="line">obj.name = <span class="string">'xxx'</span></div><div class="line">test() <span class="comment">//xxx， 随上下文对象变化</span></div></pre></td></tr></table></figure></p>
<p>此时apply方法的动态修改将不再生效，永久指向obj，obj变化时它才会变化。</p>
<h2 id="bind传参"><a href="#bind传参" class="headerlink" title="bind传参"></a>bind传参</h2><p>bind函数也可传参，而且还有点特别，这里引用mdn的例子作简要说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// Create a function with a preset leading argument</span></div><div class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">null</span>, <span class="number">37</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); </div><div class="line"><span class="comment">// [37]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// [37, 1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>bind 的第一个参数如果不是对象，会被包装成对象类型传入。</p>
<h1 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h1><p>其实刚才举例大多已经是组合使用，都是与this的组合，下面举两个个三者组合的例子。</p>
<h2 id="fn-bind-apply"><a href="#fn-bind-apply" class="headerlink" title="fn.bind.apply"></a>fn.bind.apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a1, a2</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a1+a2)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.bind.apply(fn, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = test(add, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// '[Function: bound add]'</span></div><div class="line">bar() <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>apply的作用是调用一个函数，可以修改运行时的上下文对象。<br>在这里apply调用的同样是一个函数<code>fn.bind</code>, 指定它的this对象指向<code>fn</code>，并提前传入参数<code>arguments</code>。<br>bind函数的作用是返回一个新函数，于是<code>fn.bind.apply(fn, arguments)</code>返回了一个新函数。通过打印可以看到，打印上文的<code>bar</code>显示<code>[Function: bound add]</code>,此时<code>bar</code>已经是独立的函数，并且根据之前传参的介绍，参数1,2已经提前传入，所有后续调用bar函数时无需再次传参，直接调用即可。</p>
<h2 id="fn-apply-bind"><a href="#fn-apply-bind" class="headerlink" title="fn.apply.bind"></a>fn.apply.bind</h2><p>都知道函数的arguments对象其实并不是一个标准的数组对象，往往需要将它转化为数组使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通常做法是用apply或call实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)) <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arg)) <span class="comment">//true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//bind方法实现</span></div><div class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(unboundSlice);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)) <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> arg = slice(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arg)) <span class="comment">//true</span></div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>这里的<code>fn.apply.bind</code>的使用返回一个新的<code>bound apply</code>函数，它的上下文对象为<code>unboundSlice</code>。也就是说原来的apply函数必须依赖函数对象才能调用，现在可以独立调用了，此时的slice是一个包含特定this的apply方法。</p>
<h2 id="fn-bind-bind"><a href="#fn-bind-bind" class="headerlink" title="fn.bind.bind"></a>fn.bind.bind</h2><p>由第二个例子，我生生联想到这个例子，发现真的可行，足以证明我似乎好像真的理解了，差点被自己感动……<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</div><div class="line"><span class="keyword">var</span> boundBind = <span class="built_in">Function</span>.prototype.bind.bind(<span class="built_in">Function</span>.prototype.apply)</div><div class="line"><span class="keyword">var</span> boundApply = bound(slice)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>)) <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> arg = boundApply(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arg)) <span class="comment">//true</span></div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>正常人应该不会这么写的，主要为了理解，具体可自行分析。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>this实际上是在函数被调用时建立的一个绑定,具体指向跟上下文有关</li>
<li>apply、call、bind都是<code>Function.prototype</code>对象的属性，都是函数方法，都可以动态修改函数运行时的上下文对象</li>
<li>apply、call的调用会立即运行该函数</li>
<li>bind的调用会创建一个新的函数</li>
<li>apply传参必须为数组或类数组</li>
<li>call和bind传参为位置参数</li>
<li>bind函数传参会先于新函数调用时的参数传入</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现一个很有意思的现象，js中的&lt;code&gt;this&lt;/code&gt;、&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;单独拿出来都知道用法，但只要两个的组合出现时就有点蒙，三个的组合出现时开始怀疑自己是否还没入门……&lt;/p&gt;
&lt;p&gt;我想大概原因还是没有认真做过总结吧，之前已经总结过一次js中this的用法，不过那次是着重总结箭头函数中的this。这次把这几个经常见到的整合在一起再总结一次。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="this" scheme="http://xu-li.cn/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>express框架学习(中)</title>
    <link href="http://xu-li.cn/2017/express_framework/"/>
    <id>http://xu-li.cn/2017/express_framework/</id>
    <published>2017-09-19T15:11:38.000Z</published>
    <updated>2017-09-20T11:54:50.256Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结试图说明express框架运行的原理，结论都是从阅读源码得来，但文中不会提及源代码，仅作总体认知方面进行说明。</p>
<a id="more"></a>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>结合一个官网实例来说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res, next</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`receive: <span class="subst">$&#123;req.url&#125;</span>`</span>)</div><div class="line">  next()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> host = server.address().address;</div><div class="line">  <span class="keyword">var</span> port = server.address().port;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening at http://%s:%s'</span>, host, port);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如无意外，运行以上代码即实现了一个十分简单的web版hello world，控制台还有一些打印。<br>总的来说，express的对外接口设计还是十分友好实用的，这里主要用到三个API</p>
<ul>
<li>app.use, 注册中间件</li>
<li>app.METHOD，注册路由（这里用到的是具体的get方法）</li>
<li>app.listen， 创建http server，监听端口</li>
</ul>
<p>结合上例下面主要论述清楚两个问题：</p>
<ol>
<li>express在创建http server前的中间件和路由的实现</li>
<li>一条特定url的http请求是如何被express处理</li>
</ol>
<h1 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h1><p><img src="http://opxo4bto2.bkt.clouddn.com/image/png/express.png" alt="express"></p>
<h1 id="中间件及路由的挂载"><a href="#中间件及路由的挂载" class="headerlink" title="中间件及路由的挂载"></a>中间件及路由的挂载</h1><p>对应问题一。此处分为三部分：</p>
<ul>
<li>require得到的express是一个函数，调用后返回的app仍然是一个函数，得到app前已调用初始化函数<code>app.init()</code>完成一些默认设置。</li>
<li>继续调用<code>app.use</code>或<code>app.METHOD</code>函数，他们的效果是调用另一个函数<code>app.lazyrouter</code>,这个函数会给app对象动态增加<code>_router</code>属性。同时，根据<code>app.use</code>或<code>app.METHOD</code>函数的参数，封装成特定的layer对象，存放在<code>app._router.stack</code>属性中，该属性是一个数组，首次加载时会添加两个默认中间件，因此，无论是use还是get等方法添加的中间件还是路由，都会按顺序从第三个元素开始存放在stack数组中，因此调用函数的顺序很重要。</li>
<li>对于<code>app.METHOD</code>系列函数，<code>layer</code>对象会增加<code>route</code>属性，用于存放注册的路由路径（eg：”/test“)、路由方法（eg：“get”，以及相应的处理函数），如果是形如<code>app.get(&#39;/test&#39;, middleware1, ， middleware2...function(req,res){...}</code>, route的stack属性则按顺序存储对应逻辑转换的layer对象，并且<code>layer.handle</code>属性均为<code>route.dispatch</code>的bound函数</li>
</ul>
<h1 id="路由系统的工作原理"><a href="#路由系统的工作原理" class="headerlink" title="路由系统的工作原理"></a>路由系统的工作原理</h1><p>对应问题二。这里同样分成三部分：</p>
<ul>
<li>express内部封装了http模块，对应http的api<code>http.createServer([requestListener])</code>可知，即每次request请求事件都会调用requestListener函数，对应到express里就是<code>app</code>函数，<code>app()</code>里又调用了<code>app.handle()</code>函数。</li>
<li><code>app.handle()</code>函数做了两件事，一时增加一个默认的错误处理函数，如果此时不存在路由，则直接调用该错误处理函数，否则调用<code>app._router.handle()</code>函数，同时将错误处理函数作为第三个参数传入。</li>
<li><code>app._router.handle()</code>函数完成了匹配与分发的路由工作，这里通过<code>next</code>函数来控制遍历<code>app._router.stack</code>，每次调用按顺序处理一个layer，先调用<code>layer.match()</code>判断是否匹配路由，如果匹配则调用<code>layer.handle_request</code>从而调用<code>layer.handle()</code>处理函数，否则调用<code>layer.handle_error()</code>处理错误。如果继续调用<code>next()</code>函数则继续处理下一个layer, 否则视为处理结束。如果是人为的漏掉next，则会导致后续处理不会被调用。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>express 结合node自带的http模块，站在巨人的肩膀展现了封装的艺术。良好的层次结构，友好实用的api设计都是值得学习和借鉴的，后续会再尝试研究细节的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结试图说明express框架运行的原理，结论都是从阅读源码得来，但文中不会提及源代码，仅作总体认知方面进行说明。&lt;/p&gt;
    
    </summary>
    
      <category term="express" scheme="http://xu-li.cn/categories/express/"/>
    
    
      <category term="Node.js" scheme="http://xu-li.cn/tags/Node-js/"/>
    
      <category term="express" scheme="http://xu-li.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>express框架学习(上)</title>
    <link href="http://xu-li.cn/2017/express-basic/"/>
    <id>http://xu-li.cn/2017/express-basic/</id>
    <published>2017-09-04T12:46:55.000Z</published>
    <updated>2017-09-20T11:55:10.215Z</updated>
    
    <content type="html"><![CDATA[<p>项目中选用的web框架是express，总结下经验<br><a id="more"></a></p>
<h1 id="express是做什么的"><a href="#express是做什么的" class="headerlink" title="express是做什么的"></a>express是做什么的</h1><p>从官网所得描述是基于node.js的一个简洁灵活的web框架，性能上没有对node进行二次抽象，也就是说express的性能的上限就是node本身的性能。<br>那就先从node本身说起。</p>
<p>网络编程这块，node代表性的有两大模块，<code>net</code>和<code>http</code>，（<code>https</code>基于<code>http</code>先不提）</p>
<p>使用<code>net</code>模块写一个简单的<code>hello world</code>服务器如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> net.Server()</div><div class="line"></div><div class="line">server.listen(<span class="number">3329</span>)</div><div class="line"></div><div class="line">server.on(<span class="string">'connection'</span>, (socket)=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`receive a connection from <span class="subst">$&#123;socket.address().address&#125;</span>`</span>)</div><div class="line">    socket.on(<span class="string">'data'</span>, (data)=&gt;&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`receive:\n<span class="subst">$&#123;data&#125;</span>`</span>)</div><div class="line">        socket.write(<span class="string">"HTTP/1.1 200 OK \n\nHello World!\r\n"</span>)</div><div class="line">        socket.destroy()</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>node运行后，可以在浏览器访问<code>http://localhost:3329/</code>,没什么意外的话就能看到熟悉的hello world。这里运用的是socket编程。<br>浏览器每一次的http请求和服务器建立一次socket连接。从收到的内容打印看，收到的确实是http格式的请求，服务器的回复也是符合http的响应格式的。<br>响应头加两个换行符后接响应体，少一个换行符就看不到hello world了。<br>但这个服务器太简陋了，它分不清不同的请求，所有都回复相同的内容。原因当然是没有解析请求的数据了，需要解析打印出来的<code>data</code>内容。</p>
<p>于是就有了下面这段代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`receive a request: <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span> HTTP<span class="subst">$&#123;req.httpVersion&#125;</span>`</span>);</div><div class="line">    res.write(<span class="string">"Hello, World!"</span>)</div><div class="line">    res.end()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">3329</span>)</div></pre></td></tr></table></figure>
<p>和上面功能相同，但仿佛更加简洁了。可以直接得到请求的url，以及回响应时不用关心响应的格式，直接写我们最关注的响应体就可以了。这些方便正是http模块相对于net模块，做了更多的封装，完成了解析请求数据的工作，并提供十分便捷的API。<br>到这个版本就可以针对不同的访问请求回复不同的响应了，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`receive a request: <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span> HTTP<span class="subst">$&#123;req.httpVersion&#125;</span>`</span>);</div><div class="line">    <span class="keyword">if</span>(req.method === <span class="string">'GET'</span> &amp;&amp; req.url === <span class="string">'/'</span>)&#123;</div><div class="line">        res.write(<span class="string">"Welcome Home!"</span>)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        res.write(<span class="string">"Hello, World!"</span>)</div><div class="line">    &#125;</div><div class="line">    res.end()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">3329</span>)</div></pre></td></tr></table></figure></p>
<p>当访问<code>`http://localhost:3329/hello</code>时返回<code>Hello, World!</code>，访问<code>http://localhost:3329/</code>, 返回<code>Welcome Home!</code>。<br>当然这是一个非常粗糙的实现，如果页面较多时代码将变得极其难看和很难维护。</p>
<p>下面该<code>express</code>登场了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="keyword">var</span> server = http.createServer(app)</div><div class="line">server.listen(<span class="number">3329</span>)</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, (request, response)=&gt;&#123;</div><div class="line">    response.send(<span class="string">'Welcome Home!'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.get(<span class="string">'/hello'</span>, (request, response)=&gt;&#123;</div><div class="line">    response.send(<span class="string">'Hello World!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>同样实现了之前的需求，但是写法简洁清晰不少，最重要的是方便维护。除此之外，引入的<code>express</code>、<code>app</code>、<code>request</code>、<code>response</code>，都提供了极其丰富且实用的API，具体可参考<a href="http://expressjs.com/en/4x/api.html" target="_blank" rel="external">官网API</a>。<br>然而以上是比较老的写法，最新版本的express写法更加简单，http模块整个都被封装了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">var</span> app = express()</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Hello World'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(<span class="number">3329</span>)</div></pre></td></tr></table></figure></p>
<p>总的来说就是，node.js自带web server，express为该server打造了更加健壮的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中选用的web框架是express，总结下经验&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="http://xu-li.cn/tags/Node-js/"/>
    
      <category term="express" scheme="http://xu-li.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中的编码问题</title>
    <link href="http://xu-li.cn/2017/node_encoding/"/>
    <id>http://xu-li.cn/2017/node_encoding/</id>
    <published>2017-09-03T12:25:14.000Z</published>
    <updated>2017-09-20T11:54:25.532Z</updated>
    
    <content type="html"><![CDATA[<p>编码问题本不是一个问题，直到它主动找上你，它就是个大问题<br><a id="more"></a></p>
<p>Node用到的默认编码格式是utf8，支持的编码格式在<a href="https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings" target="_blank" rel="external">Buffer API</a>中可见，<br>默认支持的有<img src="http://opxo4bto2.bkt.clouddn.com/node_encoding_type.png" alt="supported_encoding_type"></p>
<p>很显然没有windows常用的GBK编码，那么这样就很容易产生两种不同的编码格式，只能一方迁就另一方。<br>之前的一个小项目就遇到这样一个问题，需要用户提供数据，但要求一个只会excel记录数据的普通人提供utf8编码的json格式数据实在太难为他了。最后折中的办法采用了CSV格式，原因无它，支持excel打开编辑。<br>但仍然存在一个问题，excel编辑完保存，会以默认非uf8编码格式保存，自带的保存转换也不生效，只能用一个土办法，记事本打开，另存为时指定utf8编码格式。但仅多这一个步骤也让用户叫苦不迭，偶尔忘记转码就会导致中文显示乱码。<br>因此，这个问题不得不解决。</p>
<h1 id="浅谈编码"><a href="#浅谈编码" class="headerlink" title="浅谈编码"></a>浅谈编码</h1><p>老实说，我对编码的了解无穷趋近于一无所知，所以真的是浅谈。我只知道编码不同是以不同的二进制数字表示字符，具体什么规则我真的是记不住，也无心去了解。从Node操作文件的API，我大胆来<code>猜测</code>一下它的工作流程。<br>读取文件时，API不管是<code>fs.readFile</code> 还是<code>fs.createReadStream</code><br>encoding默认均为null，即无编码，那就是不做任何处理，将码流原封不动的读取出来暂存。<br>但处理数据时，将buffer数据转为字符串处理时，默认是utf8, 并且node未提供GBK的转码方式（支持的转码格式见上图），那么问题就出现了，如果初始编码格式不是utf8，用utf8格式去解码，当然会出问题，就算我不懂编码我也知道，用一把锁的钥匙去开另一把不同的锁，打不开才是正常的。</p>
<h1 id="从源头解决问题"><a href="#从源头解决问题" class="headerlink" title="从源头解决问题"></a>从源头解决问题</h1><p>当出现乱码问题时，要知道问题的源头是用了解码格式与编码格式不匹配造成的，所有解决的问题就要两种</p>
<ul>
<li>改文件的编码方式，与解码格式匹配</li>
<li>该文件解析时的解码方式， 与编码格式匹配</li>
</ul>
<p>第一种是让数据的生产者去改，前面已经说过了，代价太大，成本过高，不切实际。<br>第二种就更头疼了，我也没办法让node支持GBK的转码啊。<br>因此，只能曲线救国了，中间加一层转码，得到用户的数据后先把它从GBK的码流转成utf8的码流，再进行解析操作，完美！</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>搜一下能将将gbk转成utf8格式的包，搜到一个<code>iconv-lite</code>, 测试可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(remote)</div><div class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(local)</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</div><div class="line">    <span class="keyword">var</span> unicodeString = iconv.decode(chunk, <span class="string">'GBK'</span>)</div><div class="line">    <span class="keyword">var</span> buf = Buffer.from(unicodeString)</div><div class="line">    <span class="keyword">if</span> (!writableStream.write(buf)) &#123;</div><div class="line">        readableStream.pause()</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">writableStream.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    readableStream.resume()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    writableStream.end()</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>核心就两句，先将码流以GBK的解码方式解成字符串，这很符合逻辑，GBK编码，GBK解码。<br><code>var unicodeString = iconv.decode(chunk, &#39;GBK&#39;)</code><br>再将字符串再转换成utf8码流。<br><code>var buf = Buffer.from(unicodeString)</code><br>你没有猜错，Buffer.from默认utf8编码，node中的输出应该都是默认这样的操作。</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>这种写法必须保证数据来源必须始终是gbk编码的，如果提供了一个utf8编码的就会出问题，那怎么解决呢？说过了我也不懂。<br>但应该能很自然想到有没有一种方式判断文件的编码方式呢，尝试搜了一下，果然还是有的，测试可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'code.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,buffer</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(buffer[<span class="number">0</span>]==<span class="number">0xff</span>&amp;&amp;buffer[<span class="number">1</span>]==<span class="number">0xfe</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'unicode'</span>)</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>]==<span class="number">0xfe</span>&amp;&amp;buffer[<span class="number">1</span>]==<span class="number">0xff</span>)&#123;</div><div class="line">   　　<span class="built_in">console</span>.log(<span class="string">'unicode big endian'</span>)</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>]==<span class="number">0xef</span>&amp;&amp;buffer[<span class="number">1</span>]==<span class="number">0xbb</span>)&#123;</div><div class="line">　　　 <span class="built_in">console</span>.log(<span class="string">'utf8'</span>)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">   　　<span class="built_in">console</span>.log(<span class="string">'else'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>差不多意思就是，文件开头的2个字节可以判断是utf8还是unicode，虽然没有GBK的判断方法，但排除法勉强能解决问题。<br>因此，之前的代码可以重构下，先判断文件编码格式，如果是utf8就不用转码了，如果不是那就认为是gbk，需要转码。<br>如果仍然出现了乱码问题，那就甩锅给用户，肯定是他们打开的方式不对，绝对不是我的bug！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次经历对编码、解码、转码的概念基本了解了。</p>
<ul>
<li>编码：字符串-&gt; 码流</li>
<li>解码：码流 -&gt; 字符串</li>
<li>转码：码流 -&gt; 字符串 -&gt; 码流<br>也就是说目前还没有把一种编码格式的码流直接转成另一种的手段，只能用相应的解码方式先还原，再重新编码，这也是符合逻辑的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编码问题本不是一个问题，直到它主动找上你，它就是个大问题&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="http://xu-li.cn/tags/Node-js/"/>
    
      <category term="encoding" scheme="http://xu-li.cn/tags/encoding/"/>
    
  </entry>
  
  <entry>
    <title>Node.js events模块(下)</title>
    <link href="http://xu-li.cn/2017/events-final/"/>
    <id>http://xu-li.cn/2017/events-final/</id>
    <published>2017-09-01T12:15:27.000Z</published>
    <updated>2017-09-20T11:55:22.909Z</updated>
    
    <content type="html"><![CDATA[<p>又一次来看这部分源码了，感觉每次依然有收获，再做一次总结，强行分成上中下三篇，内心毫无波澜，甚至有点想笑<br><a id="more"></a></p>
<h1 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h1><ul>
<li>直接引入 EventEmitter 类，new 一个对象来使用</li>
<li>从EventEmitter继承</li>
</ul>
<p>一般第二种居多，继承的方法很多，简单举例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(EventEmitter.prototype)</div></pre></td></tr></table></figure></p>
<p>现在obj对象就具备事件驱动的功能了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">obj.on(<span class="string">'test'</span>, ()=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'receive event test'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj.emit(<span class="string">'test'</span>)</div></pre></td></tr></table></figure></p>
<h1 id="事件驱动的原理"><a href="#事件驱动的原理" class="headerlink" title="事件驱动的原理"></a>事件驱动的原理</h1><p>这是一个典型的面向对象的例子，一个对象具备监听和发送消息的方法，所以关键就是这些方法的实现了。<br>该对象的两个重要属性：</p>
<ul>
<li><code>_events</code>：初始化是一个空对象，用来存储事件名及对应的回调函数。key为事件名，value为回调函数，如果回调函数超过一个，则转为一个数组，用来保证顺序。</li>
<li><code>_maxListeners</code>: 注册的最大监听数，默认值为10，这是继承的一个类属性，通过Object.defineProperty()定义。</li>
</ul>
<p>每次监听事件，即向obj._events里增加一对值，触发事件时即根据事件名调用相应回调函数，如果回调是数组类型则按顺序调用内部函数，该顺序也与注册函数时的顺序保持了一致。</p>
<h1 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h1><p>了解原理后发现其实很简单，自己也可以写一个类似的包，但这个包几经修改到当前额版本，很多细节是值得学习和借鉴的。<br>自己动手用ES6的语法写了个简易版的该模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Events</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>()&#123;</div><div class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">        <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>._maxListeners = <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getMaxListeners()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._maxListeners</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setMaxListeners(n)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> n !== <span class="string">'number'</span> || n &lt; <span class="number">0</span> || <span class="built_in">isNaN</span>(n))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span> (<span class="string">"\"n\" argument must be a positive number"</span>)</div><div class="line">        <span class="keyword">this</span>._maxListeners = n</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    on(type, listener)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span> (<span class="string">"\"n\" argument must be a positive number"</span>)</div><div class="line">        <span class="keyword">var</span> events= <span class="keyword">this</span>._events</div><div class="line">        <span class="keyword">var</span> existing = events[type]</div><div class="line">        <span class="keyword">if</span>(existing)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> existing === <span class="string">'function'</span>)</div><div class="line">                existing = [existing, listener]</div><div class="line">            <span class="keyword">else</span></div><div class="line">                existing.push(listener)</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            existing = listener</div><div class="line">        </div><div class="line">        <span class="keyword">this</span>._eventsCount++</div><div class="line">        <span class="keyword">if</span>(!existing.warn)&#123;</div><div class="line">            <span class="keyword">var</span> m = <span class="keyword">this</span>.getMaxListeners()</div><div class="line">            <span class="keyword">if</span>(m &amp;&amp; m &lt; existing.length)&#123;</div><div class="line">                existing.warned = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">const</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Possible EventEmitter memory leak detected. '</span> +</div><div class="line">                                    <span class="string">`<span class="subst">$&#123;existing.length&#125;</span> <span class="subst">$&#123;<span class="built_in">String</span>(type)&#125;</span> listeners `</span> +</div><div class="line">                                    <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</div><div class="line">                                    <span class="string">'increase limit'</span>);</div><div class="line">                w.name = <span class="string">'MaxListenersExceededWarning'</span>;</div><div class="line">                w.emitter = <span class="keyword">this</span>;</div><div class="line">                w.type = type;</div><div class="line">                w.count = existing.length;</div><div class="line">                process.emitWarning(w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        events[type] = existing</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    emit(type)&#123;</div><div class="line">        <span class="keyword">var</span> events = <span class="keyword">this</span>._events</div><div class="line">        <span class="keyword">var</span> handler = events[type]</div><div class="line">        <span class="keyword">if</span>(!handler)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</div><div class="line">        <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">          args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">        <span class="keyword">var</span> isFn = <span class="keyword">typeof</span> handler === <span class="string">'function'</span></div><div class="line">        <span class="keyword">if</span>(isFn)&#123;</div><div class="line">            handler.apply(<span class="keyword">this</span>, args)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            handler.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</div><div class="line">                v.apply(<span class="keyword">this</span>, args)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是个十分简陋的实现，对比源码就能发现很多细节非常值得推敲，这里重点说一个。</p>
<h2 id="Once的封装"><a href="#Once的封装" class="headerlink" title="Once的封装"></a>Once的封装</h2><p>源码实现了只触发一次回调函数，并几乎没有修改原来的接口。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"listener" argument must be a function'</span>);</div><div class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>完整复用了<code>on</code>的接口, _onceWrap的实现无疑值得学习。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, target, type, listener &#125;;</div><div class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</div><div class="line">  wrapped.listener = listener;</div><div class="line">  state.wrapFn = wrapped;</div><div class="line">  <span class="keyword">return</span> wrapped;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</div><div class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</div><div class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target);</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>],</div><div class="line">                                  <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">const</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i)</div><div class="line">          args[i] = <span class="built_in">arguments</span>[i];</div><div class="line">        <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.target, args);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>_onceWrap返回的是绑定了this的onceWrapper函数，存在<code>this._events</code>中。state对象做了两件事，提供this以及保存地址。<br>保存地址方面尤为巧妙，保存了自身、调用对象以及需要传递的参数。<br>其中<code>onceWrapper</code>函数中，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</div><div class="line"><span class="keyword">this</span>.fired = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>这两行只保留任何一行也不会影响结果。双重保障，即使删除listener未成功也能防止其被二次调用。</p>
<p>再总结一点，从源码可知，调用回调函数时都是绑定了this，指向调用对象本身的。因此，如果想要在回调函数中使用调用者对象，<br>则不适合使用箭头函数。箭头函数绑定父上下文，给回调函数使用apply或call绑定this无任何效果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于events模块应该不会再有总结了，毕竟题目都用完了。感觉自己还是基本掌握原理及使用的。<br>脑子里留下多少算多少，实在不行就再看一遍，不然写在这里岂不白写了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又一次来看这部分源码了，感觉每次依然有收获，再做一次总结，强行分成上中下三篇，内心毫无波澜，甚至有点想笑&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="http://xu-li.cn/tags/Node-js/"/>
    
      <category term="events" scheme="http://xu-li.cn/tags/events/"/>
    
      <category term="EventEmitter" scheme="http://xu-li.cn/tags/EventEmitter/"/>
    
  </entry>
  
  <entry>
    <title>Python中的元类</title>
    <link href="http://xu-li.cn/2017/python-metaclass/"/>
    <id>http://xu-li.cn/2017/python-metaclass/</id>
    <published>2017-08-01T13:05:27.000Z</published>
    <updated>2018-04-07T02:36:40.361Z</updated>
    
    <content type="html"><![CDATA[<p>python中的元类在大多数场景里是用不到的，但理解元类有助于深入理解python面向对象编程中实例的创建过程，应该当做基础知识掌握。</p>
<a id="more"></a>
<h2 id="python中的类"><a href="#python中的类" class="headerlink" title="python中的类"></a>python中的类</h2><p>大多数语言里，类就是一组用来描述如何生成一个对象的代码段,python里也不例外。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">obj = ObjectCreator()</div><div class="line">print(obj) <span class="comment"># &lt;__main__.ObjectCreator object at 0x0392E270&gt;</span></div></pre></td></tr></table></figure></p>
<p>除此之外，python的类同时也是一种对象，用<code>class</code>关键字声明类时，内存中就创建了一个对象，该对象具备在执行时创建一个实例对象的能力，但本质上仍然是一个对象，因此仍然可以进行如下操作：</p>
<ul>
<li>赋值给变量</li>
<li>增加它的属性</li>
<li>作为函数参数传递</li>
</ul>
<p>最重要的是，它是一个对象，那么就可以动态的创建它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_class_by_name</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> Foo</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> Bar</div><div class="line"></div><div class="line">myClass = create_class_by_name(<span class="string">'foo'</span>)</div></pre></td></tr></table></figure></p>
<p>以上代码动态的创建了一个类，这样的做法显然还不够。</p>
<p>回到类的定义，<code>类就是一组用来描述如何生成一个对象的代码段</code></p>
<p>那有没有描述如何生成一个类的代码段呢，答案当然是存在的，因为类本身也是对象。</p>
<p><code>一组用来描述如何生成一个类的代码段</code>叫做元类(metaclass)</p>
<h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h2><p>简言之，实例对象是一个类的实例，类则是元类的实例</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code>常用的用法是作为一个全局函数，得到对象类型，但它同时具备创建类的作用，即通过参数类型实现了函数的重载</p>
<pre><code>type(className, (base,), {property:value})
</code></pre><p>当且仅当传入三个参数时，返回创建的类</p>
<ul>
<li>类名字符串，</li>
<li>需要继承的父类元祖(可以为空)</li>
<li>类属性字典。</li>
</ul>
<p>看到这个api应该不用举例了，可以非常方便的创建和继承类</p>
<p>所以可以说<code>type</code>是一个类，和<code>int</code>,<code>str</code>等类一样。</p>
<p>同时还是一个<code>metaclass</code>，因为它的实例仍然是一个类</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>python里的一切皆对象，对象都是从一个类创建而来，对象本身也会携带创建它的类的信息, 这也是<code>__class__</code>属性的功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = 5</div><div class="line">&gt;&gt;&gt; a.__class__</div><div class="line">&lt;type 'int'&gt;</div><div class="line">&gt;&gt;&gt; a = 'hello'</div><div class="line">&gt;&gt;&gt; a.__class__</div><div class="line">&lt;type 'str'&gt;</div><div class="line">&gt;&gt;&gt; def foo(): pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; foo.__class__</div><div class="line">&lt;type 'function'&gt;</div><div class="line">&gt;&gt;&gt; class Bar(object): pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; b = Bar()</div><div class="line">&gt;&gt;&gt; b.__class__</div><div class="line">&lt;class '__main__.Bar'&gt;</div><div class="line">&gt;&gt;&gt; a = 6</div><div class="line">&gt;&gt;&gt; type(a) is a.__class__</div><div class="line">True</div><div class="line">&gt;&gt;&gt; a.__class__.__class__</div><div class="line">&lt;type 'type'&gt;</div></pre></td></tr></table></figure></p>
<p>注意，<code>__class__</code>的返回值并非字符串，而是和type作为对象类型判断的函数返回值相同，是一个对象，该对象是由<code>type</code>元类直接创建, </p>
<p>如果上述最后一个例子有点绕，那再看一个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Bar = type(<span class="string">'Bar'</span>, (), &#123;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Bar.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div></pre></td></tr></table></figure></p>
<p>总结来说，type作为普通函数，可以打印出创建该对象的类的类型,如’int’, ‘str’等</p>
<p>但类自身也是一个对象，也是被创建的，创建类的类被称为元类，它的类型是<code>&lt;type &#39;type&#39;&gt;</code></p>
<h2 id="metaclass-1"><a href="#metaclass-1" class="headerlink" title="__metaclass__"></a><code>__metaclass__</code></h2><p><code>__metaclass__</code>可以是一个模块级别的属性，在顶层作用域会影响模块类所有类的创建</p>
<p>也可以作为类属性，那么它将仅影响该类的创建</p>
<p>原理如下：</p>
<p>当类声明后，在内存中创建前，会先寻找<code>__metaclass__</code>属性，<br>如果存在，就用它来创建类，否则使用内建的<code>type</code>来创建该类</p>
<p>因此，<code>__metaclass__</code>属性指向的是一个用来创建类的元类，这很符合它的命名</p>
<p>具体来操作下，Take One：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMetaclass</span><span class="params">(name, base, attr)</span>:</span></div><div class="line">    <span class="keyword">return</span> type(name, base, attr)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = myMetaclass</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(Foo.__class__)</div><div class="line"></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line">print(foo.__class__)</div><div class="line"></div><div class="line"><span class="comment"># &lt;type 'type'&gt;</span></div><div class="line"><span class="comment"># &lt;class '__main__.Foo'&gt;</span></div></pre></td></tr></table></figure></p>
<p>没错，我是来搞笑的……什么都没干，但是演示了一把元类的是如何生效的，以及<code>__metaclass__</code>的使用</p>
<p>再来写个有用的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMetaclass</span><span class="params">(name, base, attr)</span>:</span></div><div class="line">    attr[<span class="string">'slogan'</span>] = <span class="string">'hello world'</span></div><div class="line">    <span class="keyword">return</span> type(name, base, attr)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = myMetaclass</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(Foo.slogan)</div><div class="line"></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line">print(foo.slogan)</div><div class="line"><span class="comment"># hello world</span></div><div class="line"><span class="comment"># hello world</span></div></pre></td></tr></table></figure></p>
<p>操作空间很大，<code>name</code>,<code>base</code>, <code>attr</code> 都是可操作对象，<br>举例是给类添加了一个固定属性，还可以动态的更改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMetaclass</span><span class="params">(name, base, attr)</span>:</span></div><div class="line">    <span class="keyword">if</span> attr.get(<span class="string">'slogan'</span>):</div><div class="line">        attr[<span class="string">'slogan'</span>] = <span class="string">'goodbye world'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        attr[<span class="string">'slogan'</span>] = <span class="string">'hello world'</span></div><div class="line">    <span class="keyword">return</span> type(name, base, attr)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = myMetaclass</div><div class="line">    slogan = <span class="string">"you can't see me"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(Foo.slogan) </div><div class="line"></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line">print(foo.slogan)</div><div class="line"></div><div class="line"><span class="comment"># goodbye world</span></div><div class="line"><span class="comment"># goodbye world</span></div><div class="line"><span class="comment"># 如果注释掉 slogan = "you can't see me"，打印会是两个 hello world</span></div></pre></td></tr></table></figure></p>
<p>这个例子展示了动态修改类属性，根据这个实例，可以大胆推断：</p>
<p>类在创建前会加载所有属性和方法，存储在一个字典中，集中所有父类到一个元祖中，然后再调用元类创建实例</p>
<p>总的来说，自定义元类的发挥作用的流程是：</p>
<ul>
<li>拦截类的创建</li>
<li>修改类, 可操作的内容有name，base，attr三个对象</li>
<li>返回修改后的类</li>
</ul>
<p>但现在的实现并非一个类，因为<code>myMetaclass</code>是一个函数，还可以再改进</p>
<h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><p>上面说了<code>__metaclass__</code>实现了动态修改类，但不太算面向对象的语法。还有更简洁的方式，那就是通过定义类的<code>__new__</code>方法</p>
<h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><p>简单来说，一个类的实例对象是<code>__new__</code>和<code>__init__</code>方法共同创造的。<br>前者创建,后者完成初始化。最后返回该对象。也就是说最终返回的对象就是<code>__new__</code>方法创建的那个。</p>
<p>来一段官方文档解释</p>
<pre><code>`__new__`方法继承自`object.__new__(cls[,...])`, 调用创建类`cls`的实例。
该静态方法接受一个`需要返回的对象的类`cls作为第一个参数，剩余参数都会被传递给对象构造表达式。
返回值应该是一个新的对象实例（通常是cls的实例）

典型用法是，以合适的参数调用超类的`__new__`方法`super(currentclass, cls).__new__(cls[, ...])`创建一个类的新实例，然后可以做一些修改，最后返回该实例

如果`__new__`返回的是cls的实例，这个实例的`__init__()`会以`__init__(self[,...])`的形式调用，`self`即新创建的对象，后续的参数即是之前传给`__new__`的剩余参数

如果`__new__`返回的不是cls的实例，那么实例的`__init__()`将不会被调用

`__new__`主要意图是那些让不可变类型（例如 int, str, tuple）的子类可以自定义实例的创建。通常也会在自定义元类中被重写，从而达到自定义类的创建
</code></pre><p>这一段我自行翻译如上，原文见 <a href="https://docs.python.org/2.7/reference/datamodel.html?highlight=__new__#object.__new__" target="_blank" rel="external"><code>object.__new__(cls[, ...])</code></a></p>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><p><a href="https://docs.python.org/2.7/reference/datamodel.html?highlight=__new__#object.__init__" target="_blank" rel="external">官方文档</a> 翻译如下：</p>
<pre><code>在实例被(`__new__`)创建后调用，参数均将被传递给类构造表达式。
如果该类所继承的基类也存在`__init__`方法，那么必须显式的调用该方法以确保实例的基类部分得到初始化。
例如`Baseclass.__init__(self[,args...])`
由于`__new__()`和`__init__()`共同作用创建的对象（前者创建，后者定制）
所以`__init__`的返回值一般为`None`，如果不是，将会在运行时抛出`TypeError`
</code></pre><p>总之，继承类需要将新创建的对象，作为基类的初始化方法的第一个参数传入并调用，从而完成继承。</p>
<p>这个过程基类并未产生实例，只是将静态方法<code>__init__</code>绑定子类创建的对象调用，完成对象的”加工”</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>举例来理解上面两段的官方文档<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">print</span> cls </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> self</div><div class="line"></div><div class="line">obj = MyClass()</div><div class="line">print(obj)</div><div class="line"><span class="comment"># &lt;class '__main__.MyClass'&gt;</span></div><div class="line"><span class="comment"># None</span></div></pre></td></tr></table></figure></p>
<p>可以看到，<code>__new__</code> 方法返回的打印的cls就是定义的<code>MyClass</code>，未定义返回对象，所有obj的值为<code>None</code>。<br>又因为返回值非cls的实例，所以<code>__init__</code> 方法根本没被调用</p>
<p>继续实践<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span></div><div class="line">        cls_instance = object.__new__(cls)</div><div class="line">        cls_instance.arg = arg</div><div class="line">        <span class="keyword">return</span> cls_instance</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></div><div class="line">        print(self.arg)</div><div class="line">        self.foo = arg + <span class="string">' world'</span></div><div class="line"></div><div class="line">obj = MyClass(<span class="string">'hello'</span>)</div><div class="line">print(obj.arg)</div><div class="line">print(isinstance(obj, MyClass))</div><div class="line"><span class="comment"># hello</span></div><div class="line"><span class="comment"># hello world</span></div><div class="line"><span class="comment"># True</span></div></pre></td></tr></table></figure></p>
<p>这一段应该很好的解释了python类创建对象的过程</p>
<ul>
<li>创建之前，首先寻找有没有实现<code>__new__</code>方法，有的话直接调用，随后根据条件判断是否调用<code>__init__</code>方法</li>
<li>如果没有重写同名类方法，则调用内部机制（这里以<code>object.__new__(cls[, ...args])</code>演示）创建类的实例并返回</li>
<li>如果返回的实对象是cls的实例，且定义了<code>__init__()</code>方法，随后该实例对象会被继续加工</li>
</ul>
<h4 id="实例小结"><a href="#实例小结" class="headerlink" title="实例小结"></a>实例小结</h4><ul>
<li>类创建时<code>MyClass(&#39;hello&#39;)</code>, 传递给<code>__new__()</code>的参数是当前类和后续参数，传递给<code>__init__()</code>的参数是创建的实例和之前的后续参数</li>
<li><code>object.__new__(cls[, ...args])</code>会返回cls的实例</li>
<li><code>__init__()</code>方法只是接受实例对象做加工，并不创建也不返回该对象。</li>
<li>由上一条可知，如果创建的对象是不可变对象，那么<code>__init__</code>方法将完全不起作用</li>
</ul>
<p>大多数情况下，是不需要使用到<code>__new__</code>方法的，它的应用场景如官方所言主要是两个</p>
<ul>
<li>自定义一些immutable对象的创建</li>
<li>还有就是前面重点说到的自定义元类了</li>
</ul>
<h4 id="动态修改类实例的创建"><a href="#动态修改类实例的创建" class="headerlink" title="动态修改类实例的创建"></a>动态修改类实例的创建</h4><p>举例说明，创建一个字符串类，要求继承自<code>str</code>类，接受一个字符串参数，返回值为该字符串加上定制的前缀<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span><span class="params">(str)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg, prefix=<span class="string">"hello "</span>)</span>:</span></div><div class="line">        print(isinstance(self, str))</div><div class="line">        str.__init__(self, prefix + arg)</div><div class="line"></div><div class="line">obj = MyString(<span class="string">'world'</span>)</div><div class="line">print(obj)</div></pre></td></tr></table></figure></p>
<p>上述代码很遗憾不会有预期的效果。</p>
<p>分析上述代码的实际工作流程是</p>
<ul>
<li>调用<code>MyString(&#39;world&#39;)</code>，不存在<code>__new__</code>方法，调用内部机制创建实例对象</li>
<li>内部机制不知道没关系（一说是type类），但<code>__init__</code>调用前实例对象必然已经创建，必然是<code>str</code>的实例，已然不可更改</li>
<li>再调用<code>__init__</code>方法，打印证实了之前的猜想</li>
</ul>
<p>因此想要实现该需求，必须在字符串对象创建时就加上前缀，一旦创建完成便是不可变对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyString(str):</div><div class="line">    def __new__(cls, arg, prefix='hello '):</div><div class="line">        return str.__new__(cls, prefix + arg)</div><div class="line"></div><div class="line">obj = MyString('world)</div><div class="line">print(obj)</div><div class="line">print(isinstance(obj, MyString))</div><div class="line">print(isinstance(obj, str))</div><div class="line">print(issubclass(MyString, str))</div></pre></td></tr></table></figure>
<p>完成了功能，顺便验证了一点，<code>str.__new__(cls[,...])</code>方法不仅可以创建cls的实例，而且cls会从str继承</p>
<p>一般为了代码可维护性以及对多重继承的支持，会选择<code>super</code>的写法<code>super(MyString, cls).__new__(cls, prefix+arg)</code></p>
<p>了解了<code>__new__</code>的用法,对比<code>__metaclass__</code>的用法,再次改写之前的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = myMetaclass</div><div class="line">    slogan = <span class="string">"you can't see me"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>实现如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    slogan = <span class="string">"you can't see me"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">if</span> hasattr(cls, <span class="string">'slogan'</span>):</div><div class="line">            cls.slogan = <span class="string">'goodbye world'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cls.slogan = <span class="string">'hello world'</span></div><div class="line">        <span class="keyword">return</span> super(Foo, cls).__new__(cls)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(Foo.slogan)</div><div class="line"></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line">print(foo.slogan)</div><div class="line"></div><div class="line"><span class="comment"># you can't see me</span></div><div class="line"><span class="comment"># goodbye world</span></div></pre></td></tr></table></figure></p>
<p>可以看出二者和<code>__new__</code>不同的地方：</p>
<ul>
<li><code>__metaclass__</code>会拦截类的创建，如果属性值存在则调用</li>
<li><code>__new__</code>只是在运行时修改类，未调用前是不会生效的，达到动态修改的目的</li>
</ul>
<p>除此之外，<code>__new__</code>最常用的的用法是实现一个单例类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'instance'</span>):</div><div class="line">            cls.instance = object.__new__(cls)</div><div class="line">        <span class="keyword">return</span> cls.instance</div><div class="line"></div><div class="line">obj1 = Singleton()</div><div class="line">obj2 = Singleton()</div><div class="line"></div><div class="line">obj1.key = <span class="string">'value'</span></div><div class="line"><span class="keyword">print</span> obj1.key, obj2.key</div><div class="line"></div><div class="line"><span class="keyword">print</span> obj1 <span class="keyword">is</span> obj2</div></pre></td></tr></table></figure></p>
<h4 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h4><p>自定义元类, 以type元类为基类即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMetachass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, base, attrs)</span>:</span></div><div class="line">        print(attrs[<span class="string">'slogan'</span>])</div><div class="line">        attrs[<span class="string">'slogan'</span>] = <span class="string">'guess what'</span></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, base, attrs)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = MyMetachass</div><div class="line">    slogan = <span class="string">"you can't see me"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(Foo.slogan)</div><div class="line"></div><div class="line">foo = Foo()</div><div class="line"></div><div class="line">print(foo.slogan)</div></pre></td></tr></table></figure></p>
<p>效果和最开始的例子相同，也更符合面向对象的写法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇的内容有点多，本来也是想到哪儿写到哪儿，本来只想写metaclass的，一不小心没把持住……当然也还有很多没有展开，我猜太长自己都没耐心看，再次提炼一下本文中心思想。</p>
<ul>
<li>元类(metaclass)就是实例为class的class</li>
<li>type接收一个参数时是返回对象类型，接收三个参数时是一个元类。两种情况下的返回值均为type类</li>
<li>对象的<code>__class__</code>属性反映了创造它的类的类型，返回值是type类</li>
<li><code>__metaclass__</code>可以作为类属性，也可以作为模块属性，会拦截类的创建，会调用属性值来完成类的创建，属性值为一个可调用对象，接受的参数和type元类相同</li>
<li><code>__metaclass__</code>的效果会隐式的继承到子类，也会拦截子类的创建</li>
<li><code>__new__(cls[,...])</code>是<code>object</code>上的静态方法，作用是返回接受的第一个参数类的实例对象。可重写该方法动态的修改类</li>
<li><code>__init__(self[,...])</code>, 第一个参数为<code>__new__()</code>返回的对象，完成对象的初始化</li>
<li><code>__metaclass__</code>和<code>__new__()</code>可以联合使用，关键点在于将type看成一个类，可以从它继承进而生成定制元类</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中的元类在大多数场景里是用不到的，但理解元类有助于深入理解python面向对象编程中实例的创建过程，应该当做基础知识掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://xu-li.cn/categories/Python/"/>
    
    
      <category term="python" scheme="http://xu-li.cn/tags/python/"/>
    
      <category term="metaclass" scheme="http://xu-li.cn/tags/metaclass/"/>
    
  </entry>
  
  <entry>
    <title>RobotFramework Library API</title>
    <link href="http://xu-li.cn/2017/rf-library/"/>
    <id>http://xu-li.cn/2017/rf-library/</id>
    <published>2017-07-22T13:45:27.000Z</published>
    <updated>2018-04-07T02:44:32.175Z</updated>
    
    <content type="html"><![CDATA[<p>RF本身是用Python写的，它的扩展库也可以用Python来写。<br>如果是跑在Jython上，也是可以用java来扩展。<br>纯python的扩展具备通用性，本文也主要总结基于python的RF扩展库的API，RF版本为截止到当前最新的V3.0.2<br><a id="more"></a></p>
<h2 id="API-分类"><a href="#API-分类" class="headerlink" title="API 分类"></a>API 分类</h2><p>RF有三种不同的库API:</p>
<ul>
<li>静态API, 最常用的。提供一个包或者一个类，里面的公有方法名会被映射为<code>关键字名</code></li>
<li>动态API, 动态的生成和执行关键字，除了运行时生成的特点，其他和静态API相同</li>
<li>混合API, 即动态的引用静态API创建的关键字</li>
</ul>
<p>本文仅总结静态API,其它两类差不太多，只是有一些炫酷的用法而已</p>
<h2 id="创编Library库"><a href="#创编Library库" class="headerlink" title="创编Library库"></a>创编Library库</h2><p>Library的名字导入后会和包名或者类名保持一致</p>
<p>eg：现在引入一个Python库 MyLibrary(一个文件，MyLibrary.py)，<br>它将创建一个名字也为MyLibrary的库</p>
<h3 id="编写类"><a href="#编写类" class="headerlink" title="编写类"></a>编写类</h3><p>通常一个包里包含的是一个类，如果类名和包名相同，RF允许在导入时省略类名</p>
<p>如果类名和包名不一致，则Library名需要补全导入的类名</p>
<p>举例说明<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Test.py</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''testing library'''</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, str1, str2)</span>:</span></div><div class="line">        <span class="keyword">return</span> str1 + str2</div></pre></td></tr></table></figure></p>
<p>现在引入<code>Test.py</code>, 则库名为<code>Test</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Library     Test</div></pre></td></tr></table></figure></p>
<p>此时<code>foo</code>关键字可以直接使用，接受两个参数返回拼接后的内容</p>
<p>但如果改变类名为<code>Foo</code>, 在执行就会报错<code>找不到关键字foo</code></p>
<p>这个时候两个解决方案，将类名改成和包名一致，或者更改导入库如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Library     Test.Foo</div></pre></td></tr></table></figure></p>
<p>其实，之前的导入库相当于<code>Test.Test</code>的别名</p>
<h3 id="编写函数和变量"><a href="#编写函数和变量" class="headerlink" title="编写函数和变量"></a>编写函数和变量</h3><p>除了类之外也可以创建变量和函数, 包命名空间里的方法也会变成关键字</p>
<p>包括导入的库名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</div><div class="line"></div><div class="line">bar = <span class="number">233</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure></p>
<p>分别引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Library           test</div><div class="line">Variables         test.py</div></pre></td></tr></table></figure></p>
<p><code>current_thread</code>和<code>test</code>会成为关键字</p>
<p><code>${bar}</code>会成为可使用的变量</p>
<p>函数、变量不能和类同时导出</p>
<p>原因我猜大概是导出类时其实是精确指定类名了，自然不会包括其他内容</p>
<p>如果不想current_thread被导出，有两种方法</p>
<ul>
<li>导入时，写成<code>import threading</code>,使用时写成<code>threading.current_thread()</code></li>
<li>通过包属性<code>__all__</code>限定导出的方法和变量</li>
</ul>
<h3 id="库参数"><a href="#库参数" class="headerlink" title="库参数"></a>库参数</h3><p>如果是导入的是一个类，自然是可以接受参数的，这些参数会被传递给构造器创建类实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*** Settings ***</div><div class="line">Library    MyLibrary     10.0.0.1    8080</div><div class="line">Library    AnotherLib    $&#123;VAR&#125;</div></pre></td></tr></table></figure></p>
<p>参数会保证顺序和个数传递，这个很好理解</p>
<p>需要注意的是RF里默认的参数类型是字符串，所以传递的数字会被转换</p>
<h3 id="库引入方式"><a href="#库引入方式" class="headerlink" title="库引入方式"></a>库引入方式</h3><p>一般Library为一个文件或第三方库，引入的方式有两种：</p>
<ul>
<li>在测试套里直接引入<code>Library</code></li>
<li>在测试套里引入<code>Resource</code>，在Resource文件里引入Library</li>
</ul>
<p>第二种方式多用于多处引入或批量引入</p>
<h3 id="库作用域"><a href="#库作用域" class="headerlink" title="库作用域"></a>库作用域</h3><p>当引入的库是各种类时，它们是可以有一个内部状态的，内部状态会在初始化和关键字执行时被改变，同时也会影响关键字的行为。</p>
<p>说简单点就是，关键字执行其实是执行类实例的方法，那其实就是这个类实例是每个用例一个实例还是大家共有一个实例的问题</p>
<p>默认行为是每个用例一个实例，互不影响</p>
<p>但这个行为也是可控的，通过一个类属性<code>ROBOT_LIBRARY_SCOPR</code></p>
<p>该属性有三个值</p>
<ul>
<li><code>TEST_CASE</code>, 默认值</li>
<li><code>TEST_SUIT</code>, 一个测试套共用一个实例</li>
<li><code>GLOBAL</code>, 全局单例</li>
</ul>
<p>eg：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleLibrary</span>:</span></div><div class="line"></div><div class="line">    ROBOT_LIBRARY_SCOPE = <span class="string">'TEST SUITE'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._counter = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></div><div class="line">        self._counter += <span class="number">1</span></div><div class="line">        <span class="keyword">print</span> self._counter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear_counter</span><span class="params">(self)</span>:</span></div><div class="line">        self._counter = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<h3 id="库版本"><a href="#库版本" class="headerlink" title="库版本"></a>库版本</h3><p>同库作用域，通过类属性<code>ROBOT_LIBRARY_VERSION</code>定义</p>
<p>如果不存在会尝试从<code>__version__</code>属性读取</p>
<h3 id="文档格式化"><a href="#文档格式化" class="headerlink" title="文档格式化"></a>文档格式化</h3><p>同上，通过类型<code>ROBOT_LIBRARY_DOC_FORMAT</code>指定文档格式，后续可以使用<code>Libdoc</code>工具生成对应格式的文档</p>
<p>属性值大小写不敏感</p>
<p>可能的值有<code>ROBOT</code>(default),<code>HTML</code>,<code>TEXT</code></p>
<p>也可以使用第三方工具<code>docutil</code>,属性值为<code>reST</code></p>
<h3 id="创建静态关键字"><a href="#创建静态关键字" class="headerlink" title="创建静态关键字"></a>创建静态关键字</h3><p>前面说过，如果是静态API，RF会自动的将引入库里的公有方法转化为关键字</p>
<p>这里面仍有一些细节需要说明</p>
<ul>
<li>以下划线开头的方法会被忽略</li>
<li>关键字的解析大小写不敏感</li>
<li>关键字中的下划线和空格会被忽略</li>
</ul>
<p>eg：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_helper_method</span><span class="params">(self, arg)</span>:</span></div><div class="line">        <span class="keyword">return</span> arg.upper()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"Hello, %s!"</span> % name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_nothing</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>引用时<code>_helper_method</code>不能被使用</p>
<p><code>hello</code>方法对应的关键字可以是<code>hello</code>, <code>Hello</code>, <code>h e l l o</code></p>
<p><code>do_nothing</code>或<code>doNothing</code>的关键字名都可以是<code>Do Nothing</code></p>
<h4 id="自定义关键字名"><a href="#自定义关键字名" class="headerlink" title="自定义关键字名"></a>自定义关键字名</h4><p>关键名也可以按照自己的意愿命名</p>
<p>实现上最先想到的应该就是装饰器了，实际也是如此</p>
<p>通过<code>robot.api.deco.keyword</code>在方法上设置一个<code>robot_name</code>属性实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</div><div class="line"></div><div class="line"><span class="meta">@keyword(u'登录')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(username, password)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>使用时, 直接使用<code>登录</code>即可，原来<code>login</code>不再映射为关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*** Test Cases ***</div><div class="line">My Test</div><div class="line">    登录   $&#123;username&#125;    $&#123;password&#125;</div></pre></td></tr></table></figure></p>
<p>从RF v3.0.2开始，通过这种方式，即使是以下划线开头的私有方法也能转换为可用关键字</p>
<h5 id="关键字嵌套参数"><a href="#关键字嵌套参数" class="headerlink" title="关键字嵌套参数"></a>关键字嵌套参数</h5><p>关键字还可以接受嵌套参数，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</div><div class="line"></div><div class="line"><span class="meta">@keyword('Add $&#123;quantity:\d+&#125; Copies Of $&#123;item&#125; To Cart')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_copies_to_cart</span><span class="params">(quantity, item)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*** Test Cases ***</div><div class="line">My Test</div><div class="line">    Add 7 Copies Of Coffee To Cart</div></pre></td></tr></table></figure></p>
<h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><p>异常信息会被打印，除此之外，向标准输出流(stdout/stderr)写入的信息也会被写入log文件，同时也还可定义不同的log level</p>
<h4 id="打印级别"><a href="#打印级别" class="headerlink" title="打印级别"></a>打印级别</h4><p>默认是<code>INFO</code>, 除此之外还有<code>TRACE</code>, <code>DEBUG</code>,<code>WARN</code>,<code>ERROR</code>,<code>HTML</code></p>
<p><code>WARN</code>,<code>ERROR</code>级别的信息会被自动写入到控制台</p>
<p>如果是<code>HTML</code>, 则支持所有html语法的展现，eg：<code>&lt;b&gt;foo&lt;/b&gt;</code>，但需要慎用<code>&lt;table&gt;</code>便签，支持不是很好</p>
<h4 id="打印到控制台"><a href="#打印到控制台" class="headerlink" title="打印到控制台"></a>打印到控制台</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_keyword</span><span class="params">(arg)</span>:</span></div><div class="line">   sys.__stdout__.write(<span class="string">'Got arg %s\n'</span> % arg)</div><div class="line"></div><div class="line"><span class="comment"># The final option is using the public logging API:</span></div><div class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> logger</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_to_console</span><span class="params">(arg)</span>:</span></div><div class="line">   logger.console(<span class="string">'Got arg %s'</span> % arg)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_to_console_and_log_file</span><span class="params">(arg)</span>:</span></div><div class="line">   logger.info(<span class="string">'Got arg %s'</span> % arg, also_console=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_with_html_format</span><span class="params">()</span>:</span></div><div class="line">    logger.info(<span class="string">'&lt;i&gt;This&lt;/i&gt; is a boring example'</span>, html=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>直接使用<code>print</code>函数也行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Hello from a library.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*WARN* Warning from a library.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*ERROR* Something unexpected happen that may indicate a problem in the test.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*INFO* Hello again!'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'This will be part of the previous message.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*INFO* This is a new message.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*INFO* This is &lt;b&gt;normal text&lt;/b&gt;.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*HTML* This is &lt;b&gt;bold&lt;/b&gt;.'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'*HTML* &lt;a href="http://robotframework.org"&gt;Robot Framework&lt;/a&gt;'</span></div></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">16:18:42.123	INFO	Hello from a library.</div><div class="line">16:18:42.123	WARN	Warning from a library.</div><div class="line">16:18:42.123	ERROR	Something unexpected happen that may indicate a problem in the test.</div><div class="line">16:18:42.123	INFO	Hello again!</div><div class="line">This will be part of the previous message.</div><div class="line">16:18:42.123	INFO	This is a new message.</div><div class="line">16:18:42.123	INFO	This is &lt;b&gt;normal text&lt;/b&gt;.</div><div class="line">16:18:42.123	INFO	This is bold.</div><div class="line">16:18:42.123	INFO	Robot Framework</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RF框架包含的内容很多，了解一些基本使用足以支撑应用，更详细的用法参考<a href="http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html" target="_blank" rel="external">官方文档</a></p>
<p>本文主要参考官方文档一部分<a href="http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#id704" target="_blank" rel="external">Extending Robot Framework</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RF本身是用Python写的，它的扩展库也可以用Python来写。&lt;br&gt;如果是跑在Jython上，也是可以用java来扩展。&lt;br&gt;纯python的扩展具备通用性，本文也主要总结基于python的RF扩展库的API，RF版本为截止到当前最新的V3.0.2&lt;br&gt;
    
    </summary>
    
      <category term="RobotFramework" scheme="http://xu-li.cn/categories/RobotFramework/"/>
    
      <category term="Python" scheme="http://xu-li.cn/categories/RobotFramework/Python/"/>
    
    
      <category term="RobotFramework" scheme="http://xu-li.cn/tags/RobotFramework/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试环境搭建</title>
    <link href="http://xu-li.cn/2017/robotframework/"/>
    <id>http://xu-li.cn/2017/robotframework/</id>
    <published>2017-07-13T13:15:27.000Z</published>
    <updated>2018-03-28T12:23:33.661Z</updated>
    
    <content type="html"><![CDATA[<p>在我有限的自动化测试经历中，我接触了基于robotframework测试框架+jenkins管理平台的一整套CI测试流程，受益良多。<br>验收测试驱动(ATDD)的思想确实有助于保证产品质量，提高开发效率。总结下这块的学习经验，以后应该还用得上。<br><a id="more"></a></p>
<h2 id="robotframework"><a href="#robotframework" class="headerlink" title="robotframework"></a>robotframework</h2><p>简称<code>RF</code>,<br>详细介绍可以参考<a href="http://robotframework.org" target="_blank" rel="external">官网</a> </p>
<p>代码托管在github <a href="https://github.com/robotframework/robotframework" target="_blank" rel="external">robotframework</a></p>
<p>总的来说RF是一个为验收测试和验收测试驱动开发的自动化测试框架，技术上以关键字驱动实现测试用例的编写。</p>
<p>特点是易于使用，易扩展，结构层次分明，整个生态异常庞大。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a href="https://github.com/robotframework/robotframework/blob/master/INSTALL.rst#introduction" target="_blank" rel="external">官方安装文档</a></p>
<p>RF是用python实现的，同时也支持jython和IronPython，大部分项目应该是直接使用python</p>
<p>此处当然又会遇到python的世纪难题，到底是py2还是py3。</p>
<p>先说结论，还是py2吧</p>
<p>原因有两点</p>
<ul>
<li>RF 从v3.0开始才支持py3，但依旧支持py2</li>
<li>虽然官网推荐生态圈中的库和工具也应该开始支持py3，然而支持度还不够全面，例如官方编辑器<code>RIDE</code>依然仅支持py2，目前没看到有支持py3的计划。虽然可以选择其他编辑器，但对于新手来说不够友好，还是建议先使用RIDE的GUI界面，方便快速入门</li>
</ul>
<h4 id="安装RF"><a href="#安装RF" class="headerlink" title="安装RF"></a>安装RF</h4><ul>
<li>安装python v2.7及以上版本</li>
<li>安装robotframework, v3.0及以上版本. <code>pip install robotframework</code></li>
<li>确认已配置环境变量</li>
<li>验证安装是否成功<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">robot --version</div><div class="line">rebot --version</div></pre></td></tr></table></figure>
</li>
</ul>
<p>命令行工具介绍</p>
<ul>
<li><code>robot</code> 执行测试用例</li>
<li><code>rebot</code> log和report文件生成器。将生成的<code>output.xml</code>记录输出文件二次解析成可读性更强的<code>log.html</code>和<code>report.html</code>结果文件。作用相当于XML解析器</li>
</ul>
<p>详细信息可通过<br><code>robot--help</code> 和 <code>rebot --help</code> 查看</p>
<h4 id="安装编辑器"><a href="#安装编辑器" class="headerlink" title="安装编辑器"></a>安装编辑器</h4><p>测试用例一般编写完成保存在文件中。</p>
<p>支持多种格式的文件，例如<code>txt</code>,<code>csv</code>等。<br>更推荐带有标识的后缀名，例如<code>tests.robot</code></p>
<p>具体编写时，推荐使用官方编辑工具 <a href="https://github.com/robotframework/RIDE/wiki" target="_blank" rel="external">RIDE</a></p>
<p>官方安装文档见 <a href="https://github.com/robotframework/RIDE/wiki/Installation-Instructions" target="_blank" rel="external">RIDE Installation</a></p>
<p>总的来说就是</p>
<ul>
<li>安装wxPython依赖</li>
<li>安装ride</li>
</ul>
<p>启动编辑器</p>
<ul>
<li>运行ride.py</li>
<li>指定参数 ride.py path/to/tests</li>
<li>windows上双击桌面快捷方式</li>
</ul>
<h4 id="执行测试用例"><a href="#执行测试用例" class="headerlink" title="执行测试用例"></a>执行测试用例</h4><p>执行测试用例命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">robot [options] data_source</div><div class="line">python -m robot [options] data_source</div><div class="line">python path/to/robot [options] data_source</div></pre></td></tr></table></figure></p>
<p>所有的optsions参数可通过<code>robot --help</code>命令查看</p>
<p>常用的有：</p>
<ul>
<li><code>-t --test name *</code>, 选取指定用例名来执行测试，默认为<code>*</code>,匹配所有用例</li>
<li><code>-s --suite name *</code>, 同上，通过测试套名指定</li>
<li><code>-i --include tag *</code>, 通过标签指定</li>
<li><code>-e --exclude tag *</code>, 排除特定标签的用例</li>
<li><code>-d --outputdir dir</code>, 输出目录，默认为当前测试用例执行的路径</li>
<li><code>-o --output file</code>, 输出文件名，默认为<code>output.xml</code>, 设置为<code>NONE</code>可禁用输出。其他log、report等输出都是基于该文件，</li>
<li><code>-r --report file</code>, 测试报告名，默认<code>report.html</code>, 设置为<code>NONE</code>不输出，也可以通过<code>rebot</code>工具后续再输出</li>
<li><code>-l --log file</code>, 测试log文件名， 同上</li>
</ul>
<p><code>python -m robot</code>到RF3.0版本才支持</p>
<p>旧版本需要使用<code>python -m robot.run</code></p>
<p>解析xml也同理<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rebot output.xml</div><div class="line">python -m robot.rebot output.xml</div><div class="line">python -m robot.rebot -d ./output output.xml</div></pre></td></tr></table></figure></p>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p><a href="https://jenkins.io/" target="_blank" rel="external">jenkins</a>的logo很好的说明的它的作用，简单来说它就是一个“管家”，可以定制各种任务的构建，测试，部署等各种工作的开源自动化持续集成服务器。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>安装Java8</li>
<li>下载最新jenkins资源包<code>jenkins.war</code></li>
<li>启动<code>java -jar jenkins.war --httpPort=8080</code></li>
<li>打开浏览器网址，根据提示完成安装</li>
<li>插件下载地址  <a href="http://updates.jenkins-ci.org/download/plugins/" target="_blank" rel="external">plugins</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RF 实现了测试主体，并提供了便捷的命令行启动接口。</p>
<p>jenkins是任务执行者，定制任务然后执行启动RF测试的命令，二者相结合实现了端到端的完整测试流程</p>
<p>RF创建的测试可以说是验收测试，也可以算是单元测试和系统测试。总之，测试保证了开发质量，提升了开发效率</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我有限的自动化测试经历中，我接触了基于robotframework测试框架+jenkins管理平台的一整套CI测试流程，受益良多。&lt;br&gt;验收测试驱动(ATDD)的思想确实有助于保证产品质量，提高开发效率。总结下这块的学习经验，以后应该还用得上。&lt;br&gt;
    
    </summary>
    
      <category term="robotframework" scheme="http://xu-li.cn/categories/robotframework/"/>
    
    
      <category term="python" scheme="http://xu-li.cn/tags/python/"/>
    
      <category term="robotframework" scheme="http://xu-li.cn/tags/robotframework/"/>
    
      <category term="jenkins" scheme="http://xu-li.cn/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Object</title>
    <link href="http://xu-li.cn/2017/js-Object/"/>
    <id>http://xu-li.cn/2017/js-Object/</id>
    <published>2017-07-11T12:50:38.000Z</published>
    <updated>2017-09-20T12:34:08.434Z</updated>
    
    <content type="html"><![CDATA[<p>javascript里的对象是我一直没认真研究过的，每次看到Object的调用总觉得是高级语法。然而其实它一直都在那里，不难不易，只是我没有去了解。查了下MDN，仍旧是做下API层面的总结。<br><a id="more"></a></p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="键值对初始化"><a href="#键值对初始化" class="headerlink" title="键值对初始化"></a>键值对初始化</h2><pre><code>@param name String 
@param value Any
</code></pre><p>其中对于name参数，必须是String。<br>如果不是String会被转化为String类型。1会转为’1’、null会被转为’null’, undefined 会被转为’undefined’, true将被转为’true’。如果是对象，则调用对象的toString方法返回String。<br>特别说明下<code>__proto__</code>。如果使用它作为name，对象不会创建一个以该字符串命名的属性。因为它存在默认值，指向Object.prototype。除非提供的value是一个对象或者null，否则默认值不会改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="string">'foo'</span>, <span class="attr">b</span>: <span class="number">42</span>, <span class="attr">c</span>: &#123;&#125;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">'foo'</span>, b = <span class="number">42</span>, c = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: a, <span class="attr">b</span>: b, <span class="attr">c</span>: c&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">test</span>: <span class="number">5</span>;</div><div class="line">  get property() &#123;<span class="keyword">return</span> <span class="keyword">this</span>.test&#125;,</div><div class="line">  set property(value) &#123;<span class="keyword">if</span>(value&gt;<span class="number">10</span>) <span class="keyword">this</span>.test = value&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</div><div class="line">assert(<span class="built_in">Object</span>.getPrototypeOf(obj1) === <span class="built_in">Object</span>.prototype);</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">__proto__</span>: <span class="literal">null</span>&#125;;</div><div class="line">assert(<span class="built_in">Object</span>.getPrototypeOf(obj2) === <span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> protoObj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> obj3 = &#123;<span class="string">'__proto__'</span>: protoObj&#125;;</div><div class="line">assert(<span class="built_in">Object</span>.getPrototypeOf(obj3) === protoObj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj4 = &#123;<span class="attr">__proto__</span>: <span class="string">'not an object or null'</span>&#125;;</div><div class="line">assert(<span class="built_in">Object</span>.getPrototypeOf(obj4) === <span class="built_in">Object</span>.prototype);</div><div class="line">assert(!obj4.hasOwnProperty(<span class="string">'__proto__'</span>));</div></pre></td></tr></table></figure></p>
<p>除此之外，ES6新增了语法特性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Shorthand property names */</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'foo'</span>, b = <span class="number">42</span>, c = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o = &#123;a, b, c&#125;;</div><div class="line"><span class="comment">/* o.a =&gt; 'foo' */</span></div><div class="line"></div><div class="line"><span class="comment">/* Shorthand method names */</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  property([parameters]) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* Computed property names */</span></div><div class="line"><span class="keyword">var</span> prop = <span class="string">'foo'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  [prop]: <span class="string">'hey'</span>,</div><div class="line">  [<span class="string">'b'</span> + <span class="string">'ar'</span>]: <span class="string">'there'</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">/* However, JSON.parse() will reject computed property names </span></div><div class="line">and an error will be thrown */</div></pre></td></tr></table></figure></p>
<p>总之一个对象的初始化就是一个表达式，用来描述一个对象的初始化过程。对象由属性组成，属性是用来描述对象的。对象的属性值可以是基本数据类型值（即js六大基本数据类型，string、number、boolean、undefined、null、symbol），也可以是对象</p>
<h2 id="用作构造器"><a href="#用作构造器" class="headerlink" title="用作构造器"></a>用作构造器</h2><pre><code>new Object([value])
根据所给的value，返回一个对象包装器。
</code></pre><p>如果value的值为null或者undefined，会构造返回一个空对象；如果value是一个对象，则返回value；否则返回所给定value类型对应的对象。</p>
<h1 id="Object属性"><a href="#Object属性" class="headerlink" title="Object属性"></a>Object属性</h1><h2 id="Object-length"><a href="#Object-length" class="headerlink" title="Object.length"></a>Object.length</h2><pre><code>返回 1
</code></pre><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><pre><code>返回一个对象，包含的属性被其他对象继承，几乎所有对象都从这里继承。
Object.prototype对象的属性不可枚举(not enumerable), 不可赋值(not writable), 
不可更改或删除(not configurable),可通过 `in` 来确定是否存在某一属性。
</code></pre><h3 id="Object-prototype-constructor"><a href="#Object-prototype-constructor" class="headerlink" title="Object.prototype.constructor"></a>Object.prototype.constructor</h3><pre><code>返回一个访问描述符(accessor property)，对象的构造函数
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.constructor === <span class="built_in">Object</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">o.constructor === <span class="built_in">Object</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">a.constructor === <span class="built_in">Array</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>;</div><div class="line">a.constructor === <span class="built_in">Array</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</div><div class="line">n.constructor === <span class="built_in">Number</span>;</div></pre></td></tr></table></figure>
<p>其中对象的构造函数可以被改变，<br>但对基本类型数据number、boolean、string的构造函数进行更改不会生效。</p>
<pre><code>undefined、null不含有constructor属性
</code></pre><h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.__proto__"></a><code>Object.prototype.__proto__</code></h3><pre><code>非标准规范，但被广泛实现。返回当前对象的原型对象，也是一个访问描述符，
可以获取也可以修改，但是修改非常影响性能，不鼓励使用。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> shape = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">let</span> p = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">shape.prototype.__proto__ = p;</div><div class="line"></div><div class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> shape();</div><div class="line"></div><div class="line">shape.prototype.a() <span class="comment">/* aaa */</span></div><div class="line"><span class="built_in">console</span>.log(shape.prototype.hasOwnProperty(<span class="string">'a'</span>)); <span class="comment">/* false */</span></div><div class="line">circle.a(); <span class="comment">// aaa</span></div></pre></td></tr></table></figure>
<h3 id="Object-prototype-defineGetter"><a href="#Object-prototype-defineGetter" class="headerlink" title="Object.prototype.__defineGetter__()"></a><code>Object.prototype.__defineGetter__()</code></h3><h3 id="Object-prototype-defineSetter"><a href="#Object-prototype-defineSetter" class="headerlink" title="Object.prototype.__defineSetter__()"></a><code>Object.prototype.__defineSetter__()</code></h3><pre><code>设置对象的getter和setter，非标准，可以被类方法Object.defineProperty代替
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.__defineGetter__(<span class="string">'gimmeFive'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;);</div><div class="line"><span class="built_in">console</span>.log(o.gimmeFive); <span class="comment">/* 5  */</span></div><div class="line">o.gimmeFive = <span class="number">10</span></div><div class="line"><span class="built_in">console</span>.log(o.gimmeFive); <span class="comment">/* 5 */</span></div><div class="line"></div><div class="line">o.__defineSetter__(<span class="string">'value'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;<span class="keyword">this</span>.test = val;&#125;);</div><div class="line">o.value = <span class="number">10</span></div><div class="line"><span class="built_in">console</span>.log(o.value); <span class="comment">/* undefined */</span></div><div class="line"><span class="built_in">console</span>.log(o.test); <span class="comment">/* 10 */</span></div><div class="line"></div><div class="line"><span class="comment">/* Using Object.defineProperty instead */</span></div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'foo'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.anotherValue;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.anotherValue = val;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.foo)          <span class="comment">/* undefined */</span></div><div class="line"><span class="built_in">console</span>.log(o.anotherValue) <span class="comment">/* undefined */</span></div><div class="line">o.foo = <span class="number">10</span></div><div class="line"><span class="built_in">console</span>.log(o.foo)          <span class="comment">/* 10 */</span></div><div class="line"><span class="built_in">console</span>.log(o.anotherValue) <span class="comment">/* 10 */</span></div></pre></td></tr></table></figure>
<h3 id="Object-prototype-lookupGetter"><a href="#Object-prototype-lookupGetter" class="headerlink" title="Object.prototype.__lookupGetter__()"></a><code>Object.prototype.__lookupGetter__()</code></h3><h3 id="Object-prototype-lookupSetter"><a href="#Object-prototype-lookupSetter" class="headerlink" title="Object.prototype.__lookupSetter__()"></a><code>Object.prototype.__lookupSetter__()</code></h3><pre><code>返回对象的getter和setter函数，非标准，可以被类方法Object.getOwnPropertyDescriptor代替
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  get foo() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">'foo'</span> : <span class="string">'bar'</span>;</div><div class="line">  &#125;，</div><div class="line">  set foo(value) &#123;</div><div class="line">    <span class="keyword">this</span>.bar = value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*  Non-standard and deprecated way */</span></div><div class="line">obj.__lookupGetter__(<span class="string">'foo'</span>);</div><div class="line"><span class="comment">/*  (function() &#123; return Math.random() &gt; 0.5 ? 'foo' : 'bar'; &#125;) */</span></div><div class="line">obj.__lookupSetter__(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">/*  (function(value) &#123; this.bar = value; &#125;) */</span></div><div class="line"></div><div class="line"><span class="comment">/*  Standard-compliant way */</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"foo"</span>).get;</div><div class="line"><span class="comment">/*  (function() &#123; return Math.random() &gt; 0.5 ? 'foo' : 'bar'; &#125;) */</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>).set;</div><div class="line"><span class="comment">/*  (function(value) &#123; this.bar = value; &#125;) */</span></div></pre></td></tr></table></figure>
<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><pre><code>@param prop String|Symbol
返回bool，判断该对象是否有某自定义属性，排除继承选项。
</code></pre><p>允许对象改写改方法，因此可用下面的方式调用更加安全<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&#123;&#125;).hasOwnProperty.call(obj, prop)</div><div class="line"><span class="comment">/* or this way */</span></div><div class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);</div></pre></td></tr></table></figure></p>
<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><pre><code>@param object Object
返回bool，判断函数调用对象是否在参数对象的原型链上
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Test()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Test.prototype.isPrototypeOf(test));</div><div class="line"><span class="comment">/* true /*</span></div><div class="line">console.log(Object.prototype.isPrototypeOf(&#123;&#125;));</div><div class="line">//true</div></pre></td></tr></table></figure>
<h3 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h3><pre><code>obj.propertyIsEnumerable(prop)
判断对象属性是否可枚举
</code></pre><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><pre><code>返回字符串代表对象，Array, Number, Date 对象重写了该方法
</code></pre><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><pre><code>返回对象的基本数据类型值，一般用在需要将对象转换成基本类型值的场景，比如运算操作。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyNumberType</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.number = n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyNumberType.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> MyNumberType(<span class="number">4</span>);</div><div class="line">myObj + <span class="number">3</span>; <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<h1 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h1><p>相当于类方法</p>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><pre><code>用法：Object.defineProperty(obj, prop, descriptor)
返回传入的对象
</code></pre><p>可以给一个对象定义新属性，也可以修改已有属性，返回传入的对象<br>普通的对象属性赋值使得它的属性可以被枚举，属性值可以被修改还可以被delete删除。但该方法允许一些更细节的操作，比如通过该方法增加的属性默认不可枚举也不能删除。<br>@descriptor 参数有两种呈现风格，数据描述符(data descriptors) 和 访问描述符(accessor descriptors)。<br>共同点是，二者都是对象，因此不可缺省。且都有如下属性</p>
<pre><code>configurable：默认false，只有当为true时，该属性才能被修改和删除,
            修改指不能二次修改定义，和writeable为true时的修改值不冲突
enumerable：默认为false，只有当为true时，才会在枚举时出现
</code></pre><p>数据描述符还有以下可选属性：</p>
<pre><code>value：属性值，可以是任何合法数据类型，对象或函数等等，默认undefined
writable：默认false，只有当true时，属性值才能被赋值运算符改变
</code></pre><p>访问描述符有以下可选属性：</p>
<pre><code>get：属性的getter函数，函数返回值将作为属性值，默认为undefined
set：属性的setter函数，默认为undefined
</code></pre><p>以上可选属性都不是必要的，如果要使用，有且只能使用二者中的一个。定义属性时，也要考虑对象的原型链继承，如需得到一个纯净的对象可以使用<code>Object.create(null)</code></p>
<h2 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h2><pre><code>Object.defineProperties(obj, props)
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</div><div class="line">  <span class="string">'property1'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">'property2'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">'Hello'</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// etc. etc.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto[, propertiesObject])"></a>Object.create(proto[, propertiesObject])</h2><pre><code>返回一个新对象，它有着具体的原型和属性
@param proto Object|null //创建的新对象的prototype
@param propertiesObject Object|null 
//可选，如果给定且不为undefined，那么它的值只能个对象，否则会报TypeError。
该对象的自定义属性会以对应的属性名添加到新建的对象应Object.defineProperties()的第二个参数。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)  </div><div class="line"><span class="comment">/* equals to: */</span></div><div class="line"><span class="keyword">var</span> o = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">o = <span class="keyword">new</span> Constructor();</div><div class="line"><span class="comment">/* is equivalent to: */</span></div><div class="line">o = <span class="built_in">Object</span>.create(Constructor.prototype);</div><div class="line"></div><div class="line">o = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">p</span>: &#123; <span class="attr">value</span>: <span class="number">42</span> &#125; &#125;);</div><div class="line">o2 = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</div><div class="line">  <span class="attr">p</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用场景:</p>
<ol>
<li>创建一个空对象，<code>Object.create(null)</code>, 返回的对象无继承属性，连<code>__proto__</code>都没有</li>
<li>实现对象的继承<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  SuperClass.call(<span class="keyword">this</span>);</div><div class="line">  OtherSuperClass.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 从一个类继承 */</span></div><div class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</div><div class="line"></div><div class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// do a thing</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><pre><code>用法：Object.assign(target, ...sources)
向target对象上增加一个或多个source对象自身的可枚举属性，
如果有相同的属性，后续的对象会覆盖前面的属性，返回target对象
assign的机制是赋值，调用source的getter，调用target的setter。而不是复制或者定义新属性。
</code></pre><p>assign的赋值不同于深度克隆<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</div><div class="line">obj2.a = <span class="number">2</span>;</div><div class="line">obj2.b.c = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">/* &#123; a: 0, b: &#123; c: 3&#125;&#125; */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">/* &#123; a: 2, b: &#123; c: 3&#125;&#125; */</span></div><div class="line"></div><div class="line"><span class="comment">/* Deep Clone */</span></div><div class="line">obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</div><div class="line"><span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</div><div class="line">obj1.a = <span class="number">4</span>;</div><div class="line">obj1.b.c = <span class="number">4</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">/* &#123; a: 4, b: &#123; c: 4&#125;&#125; */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3)); <span class="comment">/* &#123; a: 0, b: &#123; c: 0&#125;&#125; */</span></div></pre></td></tr></table></figure></p>
<p>基本类型会被包装成对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4); </div><div class="line"><span class="comment">/* Primitives will be wrapped, null and undefined will be ignored.</span></div><div class="line">   Note, only string wrappers can have own enumerable properties. */</div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></div></pre></td></tr></table></figure>
<h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h2><pre><code>Object.getOwnPropertyDescriptor(obj, prop)
@return a property descriptor if exists， undefined otherwise
</code></pre><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><pre><code>Object.getOwnPropertyDescriptors(obj)
返回对象所有属性描述符
</code></pre><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><pre><code>Object.keys(obj)
返回数组，存储着对象自身的可枚举属性
</code></pre><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><pre><code>Object.getOwnPropertyNames(obj)
返回一个数组，包含所有自身的属性名，包括不可枚举的属性
</code></pre><p>如果是数组对象，则返回所有的key以及’length’</p>
<h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>同上，只是返回的是symbol</p>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><pre><code>Object.getPrototypeOf(obj)
返回对象的原型对象，是相对于`__proto__`的正规用法
</code></pre><p>ES5里参数如果不是对象会报TypeError,ES6会将参数包装成对象，并返回其原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Proto = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Proto();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === Proto.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === obj.__proto__); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>);</div><div class="line"><span class="comment">// TypeError: "foo" is not an object (ES5 code)</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>);</div><div class="line"><span class="comment">// String.prototype                  (ES6 code)</span></div></pre></td></tr></table></figure>
<h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><pre><code>Object.setPrototypeOf(obj, prototype);
修改对象的原型对象，返回该对象。
</code></pre><p>修改对象原型存在性能问题，应尽量避免，可以使用Object.create()创建一个新对象</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><pre><code>Object.is(value1, value2);
@return bool 判断两个值是否为同一个值，和`==`、`===`均不同
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>);     <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="built_in">window</span>, <span class="built_in">window</span>);   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is([], []);           <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;);           <span class="comment">// false</span></div><div class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is(test, test);       <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>);       <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>);         <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);         <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h2><pre><code>用法：Object.freeze(obj)
返回一个对象处于不可修改的状态。修改不会生效，在Strict模式下会报错
ES5对参数不是一个对象会报错，ES6则不会，返回输入值。
</code></pre><p>然而freeze对子对象的修改并不生效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">obj1 = &#123;</div><div class="line">  <span class="attr">internal</span>: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(obj1);</div><div class="line">obj1.internal.a = <span class="string">'aValue'</span>;</div><div class="line"></div><div class="line">obj1.internal.a <span class="comment">// 'aValue'</span></div></pre></td></tr></table></figure>
<p>当然也是有办法做到递归freeze<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* To do so, we use this function. */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">/* Retrieve the property names defined on obj */</span></div><div class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</div><div class="line">  <span class="comment">/*  Freeze properties before freezing self */</span></div><div class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prop = obj[name];</div><div class="line">    <span class="comment">/*  Freeze prop if it is an object */</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop == <span class="string">'object'</span> &amp;&amp; prop !== <span class="literal">null</span>)</div><div class="line">      deepFreeze(prop);</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">/*  Freeze self (no-op if already frozen) */</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj2 = &#123;</div><div class="line">  <span class="attr">internal</span>: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">deepFreeze(obj2);</div><div class="line">obj2.internal.a = <span class="string">'anotherValue'</span>;</div><div class="line">obj2.internal.a; <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<h2 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h2><pre><code>Object.seal(obj)
返回被封装的对象，阻止增加新属性，并将已有属性改成non-configurable，如果writable为true则属性值仍旧可以修改
</code></pre><h2 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h2><pre><code>Object.preventExtensions(obj)
返回被禁止增加新属性的对象，不影响对现在属性的修改
</code></pre><h2 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h2><pre><code>Object.isExtensible(obj)
@return bool 判断一个对象是否可扩展
</code></pre><p>一般对象都是默认可扩展的，能增加新属性，也能被修改，但通过一些方法可禁止这些特性，如Object.preventExtensions(), Object.seal(), or Object.freeze().</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没啥可说的，理解了就不会觉得神奇。</p>
<p>参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Object</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript里的对象是我一直没认真研究过的，每次看到Object的调用总觉得是高级语法。然而其实它一直都在那里，不难不易，只是我没有去了解。查了下MDN，仍旧是做下API层面的总结。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xu-li.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://xu-li.cn/tags/JavaScript/"/>
    
      <category term="Object" scheme="http://xu-li.cn/tags/Object/"/>
    
  </entry>
  
</feed>
