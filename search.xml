<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[消息队列之RabbitMQ]]></title>
      <url>/2017/06/30/rabbitmq/</url>
      <content type="html"><![CDATA[<p>最近项目上开始部署了消息队列，手头的工作基本围绕着它展开。消息队列已经是比较成熟的技术了，例如使用中我们最终选择的rabbitMQ，已经诞生10年了。那这是我们选择它的原因吗？不全是，还因为它的库多……总结下这块内容以备忘！<br><a id="more"></a></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>我工作中的使用主要是使用MQ重构了原来的需求，改进的主要是</p>
<ul>
<li>和其他各个子模块之间的通信接口更加清晰，不再是只有主动发和被动收，而是收发都是主动。</li>
<li>去掉了一些中间消息的存库，改为请求后直接监听响应，减少了MongoDB的读写压力。</li>
</ul>
<p>仿佛和主流描述的使用场景刚好相反，他们说的是立即返回响应，节省请求响应时间，让MQ去处理异步事件，而我是在等异步结果回来再响应……不过工具终究是为解决实际问题的，MQ的引入确实解耦了系统，降低了复杂度，对于一些不需要二次处理结果的事件我也的确是提前给它返回了响应，这是最理想的情况，只是并非所有使用场景都是如此。</p>
<h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><ul>
<li><code>broker</code>: 按官网说法<code>RabbitMQ is the most widely deployed open source message broker</code>, 简单来说 <code>rabbitMQ &lt;= broker</code>, 即我们通常说的broker指的是rabbitMQ服务器本身。</li>
<li><code>exchange</code>: 消息交换机，消息发送者消息都是发到交换机，由交换机根据规则转发到队列，如果没有对应队列消息会被丢弃</li>
<li><code>routing key</code>: 消息发送者指定的规则，告诉交换机如何转发消息, 有时未显性展示，routing key其实为队列名</li>
<li><code>binding key</code>: 队列和交换机之间建立的规则，只有当routing key的规则符合该规则，交换机才会把消息转发至该队列</li>
<li><code>queue</code>: 队列，消息接收载体，是交换机和消息接收者之间的中间件，和交换机按照binding key的规则连接，如未显性展示，一般是绑定默认交换机，binding key为队列名，一个队列可以有多个消息接收者，这个时候的消息分配是round-table形式循环的。</li>
<li><code>producer</code>：消息生产者，就是投递消息的程序。</li>
<li><code>consumer</code>：消息消费者，就是接受消息的程序。</li>
<li><code>vhost</code>: broker的最小组成粒度，一个broker可以有多个vhost</li>
<li><code>connection</code>: 程序和broker之间的TCP连接，最大连接数取决于系统能够接受的socket连接数</li>
<li><code>channel</code>: 基于connection的虚拟连接，断开重连不需要重新建立TCP连接，减少了开销。一个connection里能建的最大channel数可以设置，服务端默认128，设为0代表无限制。channel是消息真正的操作载体，绝大多数操作都是基于channel的。</li>
<li><code>heartbeat</code>: 用于检测客户端与服务端之间的tcp链接是否正常的发包间隔，服务端默认600秒，客户端如果设置，双方会连接后会协定以客户端为主，如果客户端设置为0表示不启用该功能。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://opxo4bto2.bkt.clouddn.com/rabbitmq.png" alt="rabbitmq"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>rabbitMQ官网以6个例子当做入门教程，详见<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">RabbitMQ Tutorials</a>，提供多种客户端接口，跟着走一遍就能入门了。</p>
<p>官方的六个实例基本概括了rabbitMQ的使用场景，熟悉以后我觉得总的来说可以分为两部分，即生产者和消费者。<br>生产者不用管自己发出的消息被谁处理，怎么处理，只需要发给按约定规则（routing key）发到指定exchange即可，消费者按照自己的需求去订阅消息，不用关心消息的来源。让双线联系变成和MQ的单线联系，从而达到解耦的目的。大部分场景只要分清当前程序是producer还是consumer，逻辑就能变得简单。<br>有时需要consumer返回处理完消息的结果，即consumer需要动态的切换成producer，这个就是RPC的应用场景了，重点还是分清自己的角色就好了。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><pre><code>如果当前程序是Producer，那么只需关心自己和`exchange`之间的交互即可。
</code></pre><p>exchange 有四种类型，分别对应不同的使用场景，</p>
<ul>
<li><code>direct</code>: 一对一模式，一般以queue的名字作为key，向指定queue转发消息</li>
<li><code>fanout</code>: 广播模式，向所有绑定的queue转发消息</li>
<li><code>topic</code>:  匹配模式，binding key可以使用通配符去匹配routing key，从而获得转发消息。<code>*</code>匹配一个关键字，<code>#</code>匹配多个关键字</li>
<li><code>header</code>: 一种类似topic的扩展，完全可以用topic取代</li>
</ul>
<p>需注意的是，发送时一般会先确认exchange存在，如果传递的exchange option和实际不符会引发错误，导致channel关闭</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><pre><code>当前程序是Consumer，监听`queue`即可。
</code></pre><p>queue的创建和绑定可以协商由谁来完成，二次确认时主要保持参数一致，否则也会产生错误，导致channel关闭。<br>RPC模式我认为更像是消费者模式的一种。<br>消息处理程序监听在一个协定好的队列(queue1)上，收到消息时处理完之后，发送结果到消息里指定的队列(queue2)。<br>对于消息的发送者，先将消息发出,保证消息能被转发至queue1，随后监听在队列queue2，等待处理结果返回。<br>这里涉及到的两个队列，queue1和queue2的创建和绑定由谁来做都可以，一般为了方便就直接采取direct的消息转发机制了。</p>
<h2 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h2><p>我选用的是javascript客户端，用的包是<a href="https://github.com/squaremo/amqp.node" target="_blank" rel="external">amqplib</a>, API参考<a href="http://www.squaremobius.net/amqp.node/channel_api.html#channel_bindExchange" target="_blank" rel="external">AMQP 0-9-1 library and client for Node.JS</a><br>总结使用中遇到的一些坑：</p>
<ul>
<li>最容易出现是exchange和queue二次确认时，参数不一致导致channel关闭</li>
<li>queue的exclusive参数，表示的是该队列是此次连接私有，一旦启用其他的channel消费该队列会出错。往该队列发送消息没有问题，因为发送是通过exchange的</li>
<li>主动删除队列时，监听队列会收到一条null消息，需特殊处理</li>
<li>consumer其实就是一个注册回调函数，它是一直都在的，并不是一次消费就失效，除非channel关闭，连接断开。避免在不知情的情况下给队列绑定多个consumer</li>
<li>多个consumer绑定同一队列时，消息的分配是round-table形式的，当被分到不是自己的消息或处理失败时需要nack来决定重新分配还是丢弃</li>
<li>确定需要一个queue多个consumer时记得使用<code>prefetch</code>参数，确保消息不会在一个节点累积</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我对rabbitMQ 学习也是一个从0到1的过程，入门很快，这也得益于它的良好API设计，一切都十分合理，是一个天然的编程模型。但项目上涉及的使用都很基础，暂时没遇到什么性能问题，估计遇到也不一定能解决……所以没啥可深入写的了，只能对一些概念性的东西作总结，方便以后能快速捡起来。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> RabbitMQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js 模块]]></title>
      <url>/2017/06/25/module/</url>
      <content type="html"><![CDATA[<p>Node.js 中的模块(module)是一开始就接触到的，但也许是因为它的API已足够简单，实际却从未深究过。另外在新的ES6标准里，之前所用的<code>require</code>、<code>exports</code>将被<code>import</code>、<code>export</code>取代成为新的标准。新旧更替如果两个都不懂就太尴尬了，我决定查下资料，稍微总结对比下新旧的不同，争取从不懂变成略懂。<br><a id="more"></a></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p><code>require()</code> 参数为字符串，加载模块,返回被加载模块<code>module.exports</code>的内容<br><code>require.cache</code> 返回已加载模块的对象，key为模块绝对路径名，value为module对象<br><code>require.resolve()</code> 参数为字符串，运用require()的机制去查找模块并不加载，返回模块绝对路径名<br><code>require.main</code> 源码解释<code>require.main = process.mainModule</code> 指向主模块，当不存在入口文件时返回 undefined</p>
<h1 id="require-exports"><a href="#require-exports" class="headerlink" title="require-exports"></a>require-exports</h1><p>Node应用由模块组成，采用CommonJS模块规范。根据这个标准，每一个文件就是一个模块。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。除非它主动对外提供接口。每个模块内部都有一个Module对象，代表当前模块，由模块内一个全局变量<code>module</code>表示。<br>自定义<code>module.exports</code>表示需要导出的接口。<code>exports</code>等同于module.exports的引用。<br><code>require</code>的用法：参数为字符串</p>
<ul>
<li>如果参数字符串以<code>&#39;/&#39;</code>开头，表示绝对路径</li>
<li>如果参数字符串以<code>&#39;./&#39;</code>开头，表示相当路径</li>
<li>如果参数字符串不含<code>&#39;/&#39;</code>或<code>&#39;./&#39;</code>，则表示加载的是一个默认提供的核心模块，或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）</li>
<li>如果参数字符串表示的是一个目录，则会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件</li>
<li>如果指定的模块文件没有发现，Node会尝试为文件名添加<code>.js</code>、<code>.json</code>、<code>.node</code>后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</li>
</ul>
<p>require加载模块即加载被加载模块的<code>module.exports</code>部分内容，且存入缓存，再次加载时会优先从缓存加载，相当于原模块的copy，原模块的变化不会对已加载内容产生影响。同理，如果对加载内容进行修改，相当于修改内存数据，会影响到后续使用。</p>
<h1 id="import-export"><a href="#import-export" class="headerlink" title="import-export"></a>import-export</h1><p>新的ES6标准，变化主要在于</p>
<ul>
<li>import 必须作用在顶层作用域, 不能动态加载，目前为止还不能完全取代require</li>
<li>import命令加载其他模块，<code>.js</code>后缀不可省略</li>
<li>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</li>
<li>ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错</li>
</ul>
<p>相同的是</p>
<ul>
<li>同一个模块如果加载多次，将只执行一次</li>
</ul>
<h1 id="require-module"><a href="#require-module" class="headerlink" title="require-module"></a>require-module</h1><p><code>module</code>代表当前模块，是一个对象，它的父类是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.id = id;</div><div class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</div><div class="line">  <span class="keyword">this</span>.parent = parent;</div><div class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</div><div class="line">    parent.children.push(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = Module;</div></pre></td></tr></table></figure></p>
<p>require 和 module 的关系是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Loads a module at the given file path. Returns that module's</span></div><div class="line">   `exports` property. */</div><div class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  assert(path, <span class="string">'missing path'</span>);</div><div class="line">  assert(util.isString(path), <span class="string">'path must be a string'</span>);</div><div class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="https://nodejs.org/api/globals.html#globals_require" target="_blank" rel="external">Node.js API</a><br><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc6" target="_blank" rel="external">CommonJS规范</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="external">require() 源码解读</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6 Module的语法</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> module </tag>
            
            <tag> require </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux从入门到放弃]]></title>
      <url>/2017/06/20/ubuntu/</url>
      <content type="html"><![CDATA[<p>很早就有学linux的想法，曾经也尝试过，特地装了双系统，但可能打开的姿势和时机不对，没过多久就不了了之了。如今已经工作一段时间了，感觉这是一项必须掌握的技能了。本着talk is cheap， just do it的实用主义原则，仅以使用目标为导向，逐步先达到我操作windows的水平，其他以后再说，捞着芝麻算芝麻，西瓜如果抱不动就不要了。以下以ubutun16.04为实验机，全程百度必应，行文仅为学习的总结及备忘录，内容逐步补充，内容无增加之时，则实现点题。<br><a id="more"></a></p>
<h2 id="认识目录"><a href="#认识目录" class="headerlink" title="认识目录"></a>认识目录</h2><pre><code>windows下目录就是C盘D盘之类，很好理解，系统盘和非系统盘。
</code></pre><p>那linux下呢？盗图一张如下：<br><img src="http://opxo4bto2.bkt.clouddn.com/linux_dir.png" alt="dir"><br>意思就是说只有一块盘，相当于windows下只有一个C盘。<br>根目录就是<code>/</code>，相当于windows下的<code>C:\</code>。该目录下<code>/etc</code>存放系统各种配置文件，<code>/root</code>为管理员目录，非管理员用户目录都在<code>/home</code>下等等。</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><pre><code>windows下win+R 打开命令行时，显示当前用户目录路径
</code></pre><p>但linux下win+alt+T打开terminal时，显示的符号是啥意思呢？<br>普通用户登录会显示<code>~$</code>，root用户登录显示<code>~#</code>。<br>非root（管理员）用户的符号会显示$，而root用户则会显示#（代表权力至高无上）。<br><code>~</code>代表当前用户目录，root用户则是<code>/root/</code>，非root则是<code>/home/name/</code>。<br><code>-</code>代表之前操作的目录，非常有用。</p>
<h2 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h2><pre><code>windows下编辑文件，右击选择文件打开方式，编辑，ctrl+S保存，关闭文件。
</code></pre><p>linux下键盘操作是主力。以下总结vi编辑器的基本使用。当然可以用gedit等GUI编辑器，应该就没有学习成本了。</p>
<h3 id="打开-新建文件"><a href="#打开-新建文件" class="headerlink" title="打开|新建文件"></a>打开|新建文件</h3><pre><code>可以右键打开或新建，和windows下一样，如果是命令模式，推荐使用vi
</code></pre><h3 id="vi使用"><a href="#vi使用" class="headerlink" title="vi使用"></a>vi使用</h3><p><code>vi filename</code> 不存在该文件则新建</p>
<pre><code>vi filename    （此时光标在第一行首）
vi + filename （光标在最后一行首，输入时注意加号两边空格）
vi +/pattern filename （匹配模式，光标置于匹配的第一个字段处，无匹配项会提示）
</code></pre><p>进入文件后此时是命令模式，输入字符不会显示。<br>在命令模式下输入插入命令i（insert）、附加命令a （append）、打开命令o（open）、修改命令c（change）、取代命令r或替换命令s都可以进入文本输入模式，此时编辑器下方会显示<code>-- INSERT --</code>样式,如无则需设置<code>set showmode</code>, 同理设置行号<code>set nu</code><br>在命令模式下敲【: / ?】中任一个可进入末行模式，执行完命令回到命令模式，或敲ESC退出到命令模式。<br>命令模式和末行模式我个人觉得没有明确界限，大概就是末行模式可以在屏幕上看到命令符吧<br>vi的操作的命令需熟练掌握，自行查找。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>rm -fir file|dir</code><br><code>rm file1 file2</code> 删除多个文件</p>
<pre><code>-f 强制删除，忽略不存在的文件
-i 删除前确认
-r 递归删除文件目录
</code></pre><h3 id="复制剪切文件"><a href="#复制剪切文件" class="headerlink" title="复制剪切文件"></a>复制剪切文件</h3><p><code>cp src dest</code> cp命令可自行了解<br><code>cat file1 &gt; file2</code> 也能达到复制文件的目的<br><code>mv fp1 fp2</code> 剪切意味着移动move，也可以起到更名的作用<br>针对mv说明：</p>
<pre><code>-b ：若需覆盖文件，则覆盖前先行备份。备份文件名为`filename~` 
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
-u ：若目标文件已经存在，且 source 比较新，才会更新(update)
-t ：--target-directory=DIRECTORY 即指定mv的目标目录，
    该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。
</code></pre><p>mv -u file1 file2</p>
<h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p><code>cat file1 file2 &gt; file</code><br>当<code>file</code>不存在会新建，若存在已有内容会被覆盖<br>参数：</p>
<pre><code>-n 或 --number 由 1 开始对所有输出的行数编号
-b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号
-s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行
-v 或 --show-nonprinting 展现出非打印字符
</code></pre><p>eg：把 file1 和 file2的文件内容加上行号后依次输入 file3 文件<br>    cat -n file1 file2 &gt; file3</p>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>可以使用系统自带的搜索功能，输入关键字即可，另外也可使用find命令<br><code>find /home -name &quot;*abc*&quot;</code><br><code>locate filename</code> 同样支持匹配</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><code>ls -l filename|dirname</code> 查看权限<br>权限分为读、写、执行。权限针对的三组人员，文件拥有者、用户群组、其他人<br>更改权限使用<code>chmod</code>命令，使用时 <code>chmod --help</code>查看说明<br>记住其中一种使用方法就好 <code>chmod abc file</code>,其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<pre><code>r=4，w=2，x=1 
</code></pre><p>chmod a=rwx file 和 chmod 777 file 效果相同<br>修改目录下所有文件权限则使用<code>chmod -R 777 *</code></p>
<p>修改文件拥有者和群组，使用 <code>chown</code>命令，普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员<br><code>chown [option] [new_owner]:[new_group] file</code></p>
<pre><code>-c 显示更改的部分的信息
-f 忽略错误信息
-h 修复符号链接
-R 处理指定目录以及其子目录下的所有文件
-v 显示详细的处理信息
</code></pre><p>eg: <code>chown -R -v root:admin test</code>将test目录下所有文件拥有者改为root，群组改为admin</p>
<h2 id="windows远程linux"><a href="#windows远程linux" class="headerlink" title="windows远程linux"></a>windows远程linux</h2><p>命令行远程当然是用SSH，客户端很多，推荐Xshell<br>GUI远程 也有很多选择, 例如vnc、nomachine，这里说下另一种：<br>xRDP + Xfce 实现Windows远程桌面连接</p>
<ol>
<li>安装xRDP及vncserver<br>sudo apt-get install xrdp<br>sudo apt-get install vnc4server tightvncserver</li>
<li>安装Xfce桌面环境<br>sudo apt-get install xubuntu-desktop</li>
<li>设置xRDP<br>echo xfce4-session &gt;~/.xsession</li>
<li>设置配置文件<br>sudo gedit /etc/xrdp/startwm.sh<br>在. /etc/X11/Xsession 前一行插入 xfce4-session</li>
<li>重启 xrdp<br>sudo service xrdp restart</li>
<li>windows通过mstsc连接</li>
</ol>
<p>Xface桌面tab不能自动补全的问题<br>settting-&gt;window manager-&gt;Keyboard，清除tab快捷键占用</p>
<h2 id="查杀进程"><a href="#查杀进程" class="headerlink" title="查杀进程"></a>查杀进程</h2><pre><code>`ps -e ` 查看所有进程，慢慢找吧……
`ps aux|grep &lt;key&gt;` 通过关键字查找目标进程
`sudo kill [code] &lt;PID&gt;` PID 为进程id，这个和windows下差不多
code默认为`-9`,表示发送kill信号，另外提两个
`-STOP` 停止进程，但不结束
`-CONT` 继续运行已停止的进程
</code></pre><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>对应windows的批处理<br>若执行失败时，尝试sudo执行</p>
<p>仍未放弃，待续！</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubutun </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js events模块(下)]]></title>
      <url>/2017/06/19/events-Source/</url>
      <content type="html"><![CDATA[<p>总结完<code>events</code>模块后会发现，这一块的API十分的简洁高效，对它的实现十分好奇。因为这块源码比较简短，代码编写十分规范，于是我选择更进一步，尝试下学习下源码<a href="https://github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="external">events.js</a>。<br><a id="more"></a></p>
<h2 id="模块的编写"><a href="#模块的编写" class="headerlink" title="模块的编写"></a>模块的编写</h2><p>通常我们都会自己写模块，但对比下这篇专业的，对自己以后写模块有些许启发<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  EventEmitter.init.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = EventEmitter;</div></pre></td></tr></table></figure></p>
<p>这是最开头的部分，<code>module.exports</code>写在文件开头，导出的部分一目了然，我个人比较习惯这种方式，不喜欢手动拉到最后去看这块信息。<br>另外，将要导出的函数模块化，没有把所有的内容都写到函数里面，解耦带来的好处不用赘述，也是非常合理的。<br>函数的call方法忘记的话参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">Function.prototype.call()</a></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>EventEmitter类实例化就是调用<code>EventEmitter.init()</code>函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype._events = <span class="literal">undefined</span>;</div><div class="line">EventEmitter.prototype._maxListeners = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line">EventEmitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.domain = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">if</span> (EventEmitter.usingDomains) &#123;</div><div class="line">    <span class="comment">/* if there is an active domain, then attach to it. */</span></div><div class="line">    domain = domain || <span class="built_in">require</span>(<span class="string">'domain'</span>);</div><div class="line">    <span class="keyword">if</span> (domain.active &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> domain.Domain)) &#123;</div><div class="line">      <span class="keyword">this</span>.domain = domain.active;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events || <span class="keyword">this</span>._events === <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)._events) &#123;</div><div class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">    <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="literal">undefined</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>domain 模块即将被废弃，可以不关心，从第二个if开始看。<br>这个判断的第二部分<code>this._events === Object.getPrototypeOf(this)._events)</code>存在的必要性我至今没看明白，但可以理解下字面意思。对象的<code>_events</code>属性和构造函数prototype的<code>_events</code>属性的比较，这里就是<code>undefined === undefined</code>的情况。<br>而且这里需注意<code>Object.getPrototypeOf(this)</code>和<code>this.prototype</code>不同这点，类似<code>obj.__proto__</code>和<code>obj.prototype</code>之间的关系。</p>
<p>值得学习的第二个点就是<code>this._events = Object.create(null)</code>。<br>之前的版本是<code>this._events = {}</code>。<br>所以<code>Object.create(null)</code>和<code>{}</code>之间肯定是有区别的，前者对象属性更少，创建速度更快。可参考<a href="https://www.bennadel.com/blog/2797-creating-objects-with-a-null-prototype-in-node-js.htm" target="_blank" rel="external">Creating Objects With A Null Prototype In Node.js</a></p>
<p>初始化过程很简单，就是初始化3个属性：<code>_events</code>置成一个空对象，用来后续存储监听器回调函数。<code>_eventsCount</code>属性置0，后期计数。<code>_maxListeners</code>,重写类属性<code>defaultMaxListeners</code>。<br>实例对象的其他属性和方法都从<code>EventEmitter.prototype</code>继承。</p>
<h2 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h2><p>EventEmitter类定义<code>defaultMaxListeners</code>时，用的如下实现方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* By default EventEmitters will print a warning if more than 10 listeners are</span></div><div class="line">   added to it. This is a useful default which helps finding memory leaks. */</div><div class="line"><span class="keyword">var</span> defaultMaxListeners = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(EventEmitter, <span class="string">'defaultMaxListeners'</span>, &#123;</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> defaultMaxListeners;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="comment">/* force global console to be compiled.</span></div><div class="line">       see https://github.com/nodejs/node/issues/4467 */</div><div class="line">    <span class="built_in">console</span>;</div><div class="line">    <span class="comment">/* check whether the input is a positive number (whose value is zero or</span></div><div class="line">       greater and not a NaN). */</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span> || arg &lt; <span class="number">0</span> || arg !== arg)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"defaultMaxListeners" must be a positive number'</span>);</div><div class="line">    defaultMaxListeners = arg;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>与通常使用的<code>obj.property</code>定义方式不同，这里使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty</a>。<br>应用在这里的配置使得<code>defaultMaxListeners</code>属性值不可被删除，可以赋值，且赋值前有检查。</p>
<h2 id="最大监听数的重写"><a href="#最大监听数的重写" class="headerlink" title="最大监听数的重写"></a>最大监听数的重写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Obviously not all Emitters should be limited to 10. This function allows</span></div><div class="line">   that to be increased. Set to zero for unlimited. */</div><div class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">setMaxListeners</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">'number'</span> || n &lt; <span class="number">0</span> || <span class="built_in">isNaN</span>(n))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"n" argument must be a positive number'</span>);</div><div class="line">  <span class="keyword">this</span>._maxListeners = n;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$getMaxListeners</span>(<span class="params">that</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (that._maxListeners === <span class="literal">undefined</span>)</div><div class="line">    <span class="keyword">return</span> EventEmitter.defaultMaxListeners;</div><div class="line">  <span class="keyword">return</span> that._maxListeners;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventEmitter.prototype.getMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">getMaxListeners</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $getMaxListeners(<span class="keyword">this</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里采取是如果对象属性存在就返回对象属性，否则返回类属性。<br>另外发现一个没什么意义的点，对非负数且不能为正无穷的判断这里用的是<code>typeof n !== &#39;number&#39; || n &lt; 0 || isNaN(n)</code>,在之前定义<code>defaultMaxListeners</code>属性时也有个相同的需求，写的是<code>typeof arg !== &#39;number&#39; || arg &lt; 0 || arg !== arg</code>，从这点也大概能推测这个库就不是一个人写的。其实还可以发现，最大监听数为浮点数也是可以的。<br>其次，这里之所以抽象出<code>$getMaxListeners</code>函数，而不是全部逻辑写到<code>getMaxListeners</code>里，是因为在<code>addListener</code>的接口里也需要判断当前最大监听数，提取出来可以减少重复代码。</p>
<h2 id="触发器传参的优化"><a href="#触发器传参的优化" class="headerlink" title="触发器传参的优化"></a>触发器传参的优化</h2><p>在事件触发时，触发器传递的参数数量是任意的，引用源码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">These standalone emit* functions are used to optimize calling of event</div><div class="line">handlers for fast cases because emit() itself often has a variable number of</div><div class="line">arguments and can be deoptimized because of that. These functions always have</div><div class="line">the same number of arguments and thus do not get deoptimized, so the code</div><div class="line">inside them can execute faster.</div></pre></td></tr></table></figure></p>
<p>即固定参数函数调用比不定参数的调用效率更高，因此<code>emitter.emit()</code>函数传参个数在<code>三个以内</code>效率是很高的。<br>这里再以函数为三个的情况举例说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">len = <span class="built_in">arguments</span>.length;</div><div class="line"><span class="keyword">switch</span> (len) &#123;</div><div class="line">  <span class="comment">/* fast cases */</span></div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    emitNone(handler, isFn, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">    emitOne(handler, isFn, <span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">    emitTwo(handler, isFn, <span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">    emitThree(handler, isFn, <span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>], <span class="built_in">arguments</span>[<span class="number">3</span>]);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="comment">/* slower */</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">      args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">    emitMany(handler, isFn, <span class="keyword">this</span>, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">emitThree</span>(<span class="params">handler, isFn, self, arg1, arg2, arg3</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isFn)</div><div class="line">    handler.call(self, arg1, arg2, arg3);</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> len = handler.length;</div><div class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</div><div class="line">      listeners[i].call(self, arg1, arg2, arg3);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当同一事件有多个监听者时，监听函数会被按顺序放进一个数组，这里做的操作时先复制一份这个数组，然后再依次调用内部函数。<br>也就是说，在运行期间原数组的内部的增删不会对执行产生任何影响。<br>也因为这个操作避免了一些死循环事件的发生。</p>
<h2 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h2><p>因为<code>emitter.on</code>和<code>emitter.prependListener</code>存在重复的逻辑，所以这段实现代码也单独抽象出<code>_addListener</code>函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> m;</div><div class="line">  <span class="keyword">var</span> events;</div><div class="line">  <span class="keyword">var</span> existing;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"listener" argument must be a function'</span>);</div><div class="line"></div><div class="line">  events = target._events;</div><div class="line">  <span class="keyword">if</span> (!events) &#123;<span class="comment">/* 还没看出这里if存在的意义 */</span></div><div class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">    target._eventsCount = <span class="number">0</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/* To avoid recursion in the case that type === "newListener"! Before</span></div><div class="line">       adding it to the listeners, first emit "newListener". */</div><div class="line">    <span class="comment">/* 即第一次侦听'newListener'事件不会触发'newListener' 回调函数 */</span></div><div class="line">    <span class="keyword">if</span> (events.newListener) &#123;</div><div class="line">      target.emit(<span class="string">'newListener'</span>, type,</div><div class="line">                  listener.listener ? listener.listener : listener);</div><div class="line"></div><div class="line">      <span class="comment">/* Re-assign `events` because a newListener handler could have caused the</span></div><div class="line">         this._events to be assigned to a new object */</div><div class="line">      events = target._events;</div><div class="line">    &#125;</div><div class="line">    existing = events[type];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!existing) &#123;</div><div class="line">    <span class="comment">/* Optimize the case of one listener. Don't need the extra array object. */</span></div><div class="line">    existing = events[type] = listener;</div><div class="line">    ++target._eventsCount;<span class="comment">/* 新的事件名才会增加计数 */</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">'function'</span>) &#123;</div><div class="line">	<span class="comment">/* 这一段的排序写的很有意思 */</span></div><div class="line">      <span class="comment">/* Adding the second element, need to change to array. */</span></div><div class="line">      existing = events[type] = prepend ? [listener, existing] :</div><div class="line">                                          [existing, listener]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/* If we've already got an array, just append. */</span></div><div class="line">      <span class="keyword">if</span> (prepend) &#123;</div><div class="line">        existing.unshift(listener);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        existing.push(listener);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check for listener leak */</span></div><div class="line">    <span class="keyword">if</span> (!existing.warned) &#123;</div><div class="line">      m = $getMaxListeners(target);</div><div class="line">      <span class="keyword">if</span> (m &amp;&amp; m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m) &#123;</div><div class="line">        existing.warned = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">const</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Possible EventEmitter memory leak detected. '</span> +</div><div class="line">                            <span class="string">`<span class="subst">$&#123;existing.length&#125;</span> <span class="subst">$&#123;<span class="built_in">String</span>(type)&#125;</span> listeners `</span> +</div><div class="line">                            <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</div><div class="line">                            <span class="string">'increase limit'</span>);</div><div class="line">        w.name = <span class="string">'MaxListenersExceededWarning'</span>;</div><div class="line">        w.emitter = target;</div><div class="line">        w.type = type;</div><div class="line">        w.count = existing.length;</div><div class="line">        process.emitWarning(w);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一块主要是写逻辑判断，当然代码也很精炼，特别说三点：</p>
<ul>
<li><code>newListener</code>事件注册位置很重要，必须要在其他事件之前才能出现期待的效果</li>
<li><code>newListener</code>事件的回调参数分别为新增的监听事件名和<code>listener.listener ? listener.listener : listener</code></li>
<li>在事件触发之前添加的监听器的回调函数才会被调用</li>
</ul>
<h2 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h2><p>如果事件只有一个监听函数，即<code>_events</code>对象只含有一个属性，这是采用<code>delete</code>方式删除。<br>若事件有多个监听函数，则对应是从数组中移除特定位置元素，如果是最开头的位置，当然是<code>list.shift()</code>,是末尾就用<code>list.pop()</code>,那么中间位置呢？<br>第一个想到的当然是<code>list.splice(index, 1)</code>,但这里用了更加效率的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* About 1.5x faster than the two-arg version of Array#splice(). */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spliceOne</span>(<span class="params">list, index</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = index, k = i + <span class="number">1</span>, n = list.length; k &lt; n; i += <span class="number">1</span>, k += <span class="number">1</span>)</div><div class="line">    list[i] = list[k];</div><div class="line">  list.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="once的实现"><a href="#once的实现" class="headerlink" title="once的实现"></a>once的实现</h2><p>源码采用三个函数实现了once的功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</div><div class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</div><div class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target);</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listener.call(<span class="keyword">this</span>.target, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>],</div><div class="line">                                  <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">const</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i)</div><div class="line">          args[i] = <span class="built_in">arguments</span>[i];</div><div class="line">        <span class="keyword">this</span>.listener.apply(<span class="keyword">this</span>.target, args);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, target, type, listener &#125;;</div><div class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</div><div class="line">  wrapped.listener = listener;</div><div class="line">  state.wrapFn = wrapped;</div><div class="line">  <span class="keyword">return</span> wrapped;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"listener" argument must be a function'</span>);</div><div class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>而之前的版本是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fired = <span class="literal">false</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    target.removeListener(type, g);</div><div class="line">    <span class="keyword">if</span> (!fired) &#123;</div><div class="line">      fired = <span class="literal">true</span>;</div><div class="line">      listener.apply(target, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  g.listener = listener;</div><div class="line">  <span class="keyword">return</span> g;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比较，原来的版本似乎更简洁，使用闭包, <code>fired</code>和<code>g()</code>的组合，保证<code>listener</code>只会调用一次。拆除两个函数，还是不定参数转固定参数以获取效率提升。<br>拆开只会闭包就用不上了，新版本采用了<code>bind</code>的写法，也是可以借鉴的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得对我自己现在而言，我所接触到的代码上限就是我能写出的代码上限。毫无疑问这次的源代码学习拔高了我平时接触到的代码的上限，收获也颇多，总结为以下几点：</p>
<ul>
<li>编写一个类模块时可以参考events的设计：代码解耦合，使用prototype、this等关键字，使得代码精简，结构清晰</li>
<li>尽可能的提取公共逻辑，减少代码重复</li>
<li>特殊技巧的使用可以参考，比如定义对象特殊属性、对象属性覆盖类属性的实现</li>
<li>性能提升，events模块主要涉及到空对象创建、不定参数的函数调用转为固定参数调用、删除数组中间部分元素等方法的使用</li>
</ul>
<p>最后一点是最体现能力的，推荐一个可以自己动手实践的工具<a href="https://github.com/logicalparadox/matcha" target="_blank" rel="external">matcha</a>，没有什么比自己动手更实用的方式了。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> events </tag>
            
            <tag> EventEmitter </tag>
            
            <tag> Source </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js events模块(上)]]></title>
      <url>/2017/06/18/events-API/</url>
      <content type="html"><![CDATA[<p>node.js 基于异步事件驱动(Event-driven)，这无疑也是一种十分优秀的编程思想，这里总结下其中与之相关的一个核心模块——events模块。<br>本文主要总结使用的API，具体可参考<a href="https://nodejs.org/api/events.html" target="_blank" rel="external">官网API</a><br><a id="more"></a></p>
<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p><code>events</code>是内置模块，但非全局变量，使用时需显示引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div></pre></td></tr></table></figure></p>
<p><code>events</code> 提供的接口是一个类，所有调用时赋值变量需大写，且需要自行实例化。<br>官方给出的例子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</div><div class="line">&#125;);</div><div class="line">myEmitter.emit(<span class="string">'event'</span>);</div></pre></td></tr></table></figure></p>
<p>这里使用了ES6的语法，创建一个<code>MyEmitter</code>类继承自初始类<code>EventEmitter</code>,方便自定义修改。</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>myEmitter对象，可以当做一个事件触发器，发送一个特定事件。也可以当成一个事件监听器，侦听某一特定事件，并调用对应的事件响应函数。<br>打印一下对象,可以看到有四个属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">     <span class="attr">domain</span>: <span class="literal">null</span>, <span class="comment">/*ignore*/</span></div><div class="line">     _events: &#123; <span class="attr">event</span>: [<span class="built_in">Function</span>] &#125;, <span class="comment">/*注册事件的监听函数*/</span></div><div class="line">     _eventsCount: <span class="number">1</span>,  <span class="comment">/*监听到的事件个数*/</span></div><div class="line">     _maxListeners: <span class="literal">undefined</span> <span class="comment">/*最大监听数，默认是10个，超出会报错*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>当作为触发器时，需要给处理函数传递参数。<br>如下例，其中特别说明回调函数中的this指向监听器对象，这里指的是myEmitter。如果使用箭头函数就不会这样了，这和箭头函数的特性有关，我之前已经总结过了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a, b, <span class="keyword">this</span>);</div><div class="line">  <span class="comment">/*Prints:</span></div><div class="line">       a b MyEmitter &#123;</div><div class="line">         domain: null,</div><div class="line">         _events: &#123; event: [Function] &#125;,</div><div class="line">         _eventsCount: 1,</div><div class="line">         _maxListeners: undefined &#125;*/</div><div class="line">&#125;);</div><div class="line">myEmitter.emit(<span class="string">'event'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="同步还是异步"><a href="#同步还是异步" class="headerlink" title="同步还是异步"></a>同步还是异步</h3><p>一个监听器上可以绑定多个响应函数，监听器调用响应函数默认是按照事件注册的顺序<code>同步调用</code>的，这样可以保证原有的一些业务逻辑，先注册先调用。但如果多个响应函数之间没有任何联系，就可以使用<code>setImmediate()</code>或<code>process.nextTick()</code>切换到异步流程，如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, (a, b) =&gt; &#123;</div><div class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'this happens asynchronously'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">myEmitter.on(<span class="string">'event'</span>, (a, b) =&gt; &#123;</div><div class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'this happens asynchronously, too'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">myEmitter.emit(<span class="string">'event'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="监听器响应函数可仅运行一次"><a href="#监听器响应函数可仅运行一次" class="headerlink" title="监听器响应函数可仅运行一次"></a>监听器响应函数可仅运行一次</h3><p>当使用 <code>eventEmitter.on()</code>方法监听事件时，事件发生时，每次都会调用响应函数。但换成<code>eventEmitter.once()</code>就会仅处理一次。</p>
<h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>当一个事件实例对象当发生错误时，会发出<code>error</code>事件，这将被Node.js当做特殊事件处理。<br>如果该对象未对错误事件注册任何处理函数，该错误就会上抛，打印堆栈信息，进而导致Node.js<code>进程退出</code>。所以说后果还是很严重的。<br>为防止进程崩溃，必须注册至少一个监听函数。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, (err) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">'whoops! there was an error'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*myEmitter.on('error', (err) =&gt; &#123;</span></div><div class="line">  console.error('whoops! there was an error');</div><div class="line">&#125;);*/ adviced!</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'whoops!'</span>));</div><div class="line"><span class="comment">// Prints: whoops! there was an error</span></div></pre></td></tr></table></figure></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>截止到现在，官房API总共包括了2个事件，15个方法(一个即将废弃，不做说明)</p>
<h3 id="Event：’newListener’"><a href="#Event：’newListener’" class="headerlink" title="Event：’newListener’"></a>Event：’newListener’</h3><p>当有新的监听函数注册时触发，回调函数有两个参数，监听函数名和监听函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(event, listener.name)</div><div class="line">    <span class="comment">/* print test testCb</span></div><div class="line">       and this callback will invoke before testCb*/</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'test'</span>, testCb);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCb</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'A'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'test'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Event：’removeListener’"><a href="#Event：’removeListener’" class="headerlink" title="Event：’removeListener’"></a>Event：’removeListener’</h3><p>类似’newListener’, 当某个事件的监听函数被移除时触发。<br>例如使用<code>myEmitter.once()</code>触发一次之后,监听函数就会被移除<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`add <span class="subst">$&#123;event&#125;</span>, <span class="subst">$&#123;listener.name&#125;</span>`</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'removeListener'</span>, (event, listener) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`remove <span class="subst">$&#123;event&#125;</span>, <span class="subst">$&#123;listener.name&#125;</span>`</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'test'</span>, testCb);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCb</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'A'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'test'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="EventEmitter-defaultMaxListeners"><a href="#EventEmitter-defaultMaxListeners" class="headerlink" title="EventEmitter.defaultMaxListeners"></a>EventEmitter.defaultMaxListeners</h3><p>类属性。最大默认监听数，缺省值为10，实例对象可以使用<code>emitter.setMaxListeners(n)</code>方法修改自身的最大监听数，如果直接修改<code>EventEmitter.defaultMaxListeners</code>则会影响所有实例。</p>
<h3 id="emitter-addListener-eventName-listener"><a href="#emitter-addListener-eventName-listener" class="headerlink" title="emitter.addListener(eventName, listener)"></a>emitter.addListener(eventName, listener)</h3><p><code>emitter.on(eventName, listener)</code>的简写，没有区别</p>
<h3 id="emitter-emit-eventName-…args"><a href="#emitter-emit-eventName-…args" class="headerlink" title="emitter.emit(eventName[, …args])"></a>emitter.emit(eventName[, …args])</h3><p>同步按注册顺序调用监听<code>eventName</code>的回调函数。<br>返回值为Boolean，如果该事件有监听器返回true，否则返回false</p>
<h3 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a>emitter.eventNames()</h3><p>返回一个数组，包含该监听器上注册的所有事件名</p>
<h3 id="emitter-getMaxListeners"><a href="#emitter-getMaxListeners" class="headerlink" title="emitter.getMaxListeners()"></a>emitter.getMaxListeners()</h3><p>返回当前最大监听数，该值可以由<code>emitter.setMaxListeners(n)</code>设置，默认等于<code>EventEmitter.defaultMaxListeners</code></p>
<h3 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a>emitter.listenerCount(eventName)</h3><p>返回事件名为<code>eventName</code>的监听数</p>
<h3 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a>emitter.listeners(eventName)</h3><p>返回一个事件名为<code>eventName</code>的所有监听函数的数组的拷贝</p>
<h3 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a>emitter.on(eventName, listener)</h3><p>监听事件<code>eventName</code>,触发时调用回调函数<code>listener</code></p>
<h3 id="emitter-once-eventName-listener"><a href="#emitter-once-eventName-listener" class="headerlink" title="emitter.once(eventName, listener)"></a>emitter.once(eventName, listener)</h3><p>监听事件<code>eventName</code>,首次触发时调用回调函数<code>listener</code>，然后移除监听该事件</p>
<h3 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a>emitter.prependListener(eventName, listener)</h3><p>将监听函数<code>listener</code>插入到事件<code>eventName</code>触发时处理函数队列的最前面。<br>返回值为<code>emitter</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`add <span class="subst">$&#123;event&#125;</span>, <span class="subst">$&#123;listener.name&#125;</span>`</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'test'</span>, testCb);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCb</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'A'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> that = myEmitter.prependListener(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>); <span class="comment">/* print before 'A' */</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === that); <span class="comment">/*true*/</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'test'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a>emitter.prependOnceListener(eventName, listener)</h3><p>同上，区别不再赘述</p>
<h3 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h3><p>移除某事件的所有监听<br>返回emitter</p>
<h3 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a>emitter.removeListener(eventName, listener)</h3><p>移除一个具体事件的监听，必须给出事件名和回调函数名。<br>因此，回调函数需要引用名。<br>值得注意的时，在触发某一事件后，注册在该事件上的回调函数就会按顺序执行一圈，在运行过程中再去删除监听器是不会生效的。因为……懒得写了,自己去官网看吧<br>返回emitter</p>
<h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><p>设置默认最大监听数<br>返回emitter</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结完这块官网所有API，基本掌握了如何使用，但这还远远不够。<br>events作为Node.js核心模块之一，采用纯javascript编写，暴露的API简洁实用，源码修改至今加上copyright也不过五百多行,非常适合精读。<br>本次API的总结主要为下次解读这一块的源码做铺垫。详情可参考<a href="https://github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="external">events.js</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> events </tag>
            
            <tag> EventEmitter </tag>
            
            <tag> API </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript箭头函数]]></title>
      <url>/2017/05/18/arrow_function/</url>
      <content type="html"><![CDATA[<p>js从ES6开始引入一种新函数，箭头函数。<br>它拥有无比简洁优雅的写法，不用显式的写<code>function</code>，确实方便不少。但并非适应所有的函数应用场景，这里结合资料和个人理解做个总结。<br><a id="more"></a></p>
<pre><code>An arrow function expression has a shorter syntax than a function expression 
and does not bind its own this, arguments, super, or new.target. 
These function expressions are best suited for non-method functions, 
and they cannot be used as constructors.
</code></pre><p>箭头函数相比声明式的函数表达式语法更加简洁，但它不绑定自己的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="external">super</a>, 以及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="external">new.target</a>, 箭头非常适合<code>非对象方法</code>的函数场景，而且也不能作为构造函数。</p>
<p>以上是我直接翻译的一段MDN资料,对于对象方法的使用场景特殊说明下：<br>不是说箭头函数不能用作对象方法，如果方法里不涉及this的调用，是完全可以的。<br>而如果使用了this，情况可能会和你想的不一样，这个后续会说到。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</div><div class="line">(param1, param2, …, paramN) =&gt; expression</div><div class="line"><span class="comment">/*当函数体只有一个表达式时，可以省略大括号， </span></div><div class="line">等价于: (param1, param2, …, paramN) =&gt; &#123; return expression; &#125; */</div><div class="line"></div><div class="line">(singleParam) =&gt; &#123; statements &#125;</div><div class="line">singleParam =&gt; &#123; statements &#125;</div><div class="line"><span class="comment">/*当只有一个参数时,可以省略括号 */</span></div><div class="line"></div><div class="line">() =&gt; &#123; statements &#125;</div><div class="line"><span class="comment">/* 无参数时，括号不可省 */</span></div><div class="line"></div><div class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</div><div class="line"><span class="comment">/* 给函数体加上括号，表示函数返回一个对象 */</span></div><div class="line"></div><div class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</div><div class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</div><div class="line"><span class="comment">/* 支持Rest参数和默认参数 */</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c</div><div class="line">f()  <span class="comment">//6</span></div><div class="line"><span class="comment">//支持带参数列表的解构赋值</span></div></pre></td></tr></table></figure>
<h2 id="从this说起"><a href="#从this说起" class="headerlink" title="从this说起"></a>从this说起</h2><p>this的用法，在面向对象编程的领域里显得非常的另类。<br>在箭头函数出现之前，每一个新的函数，都定义了自己的this这个特殊变量。<br>如果是作为构造函数，this指代一个新的对象;<br>如果是在strict模式下的函数调用，this被定义为undefind;<br>非strict模式则指向全局对象(window或global);<br>如果是被当做对象的方法调用，this则指代调用该方法的对象。</p>
<p>然而对于箭头函数，它不绑定自己的this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">5</span>; <span class="comment">/* nodejs 需写成 global.age = 5  */</span> </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">/* this.age = 0;//this 指向构造函数Foo的实例 */</span></div><div class="line">    <span class="keyword">var</span> test= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">/* 非strict模式下指向全局对象，非Foo的实例 */</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Foo(); </div><div class="line"><span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>如想让以上这段代码输出为0怎么办呢？<br>在ES 3/5里，this可以被赋值给其他变量，于是可以有如下的这种办法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">/* 一开始捕获this，将它存为that */</span></div><div class="line">    that.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(that.age);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Foo();</div><div class="line"><span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>当然还可以使用绑定函数，给函数绑定this的指向，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">5</span>; <span class="comment">/* 如果是nodejs，需写成global.age = 5 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> test= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> test = test.bind(<span class="keyword">this</span>);<span class="comment">/* 也可以用call或者apply </span></div><div class="line">    test.call(this, null); </div><div class="line">    test.apply(this, null); */</div><div class="line"></div><div class="line">    test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Foo();</div><div class="line"><span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<p>但是，这个场景刚好适合箭头函数登场<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> test = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Foo();</div><div class="line"><span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<p>因为箭头函数没有自己的this上下文，所以它会根据外围的上下文获取this，<br>在这里就是我们希望所希望的Foo实例对象。</p>
<pre><code>总之正常函数里使用this时，指向虽然不确定，但是至少有迹可循，
但在箭头函数里使用，就是真的不确定，因为它是绑定在外层作用域的。
倘若不使用this，只亲睐它的简洁语法，那当然就没有这些问题了。
一旦使用，就要考虑清楚它是从哪里继承。
</code></pre><p>举最后一个例子,验收测试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> foo()()()()     <span class="comment">/* this ? */</span></div><div class="line">foo()()()()         <span class="comment">/* this ? */</span></div></pre></td></tr></table></figure></p>
<p>这段代码的两个结果分别是什么呢？可以自己验证下。<br>答案如下:<br>第一个this指向foo()的实例对象<br>第二个指向全局对象</p>
<h2 id="依次类推"><a href="#依次类推" class="headerlink" title="依次类推"></a>依次类推</h2><p>说完this，同理对一开始说到的arguments, super等也是适用的<br>参考下面这段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> test = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"args:"</span>, <span class="built_in">arguments</span>);</div><div class="line">   &#125;</div><div class="line">   test()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</div><div class="line"><span class="comment">// args: &#123;'0':2, '1':4, '2':6, '3':8&#125;</span></div></pre></td></tr></table></figure></p>
<p>箭头函数没有自己的arguments, 它就取Foo()的arguments。和不绑定this一个道理。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>箭头函数的箭头和参数之间不能有换行，否则报语法错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span></span></div><div class="line">           =&gt; <span class="number">1</span>; </div><div class="line"><span class="comment">// SyntaxError: expected expression, got '=&gt;'</span></div></pre></td></tr></table></figure></p>
<p>箭头符号不是一个操作符，但会被误认为操作符，和其他操作符混用时需注意<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> callback;</div><div class="line"></div><div class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">/* ok */</span></div><div class="line"></div><div class="line">callback = callback || <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;      </div><div class="line"><span class="comment">/* SyntaxError: invalid arrow-function arguments */</span></div><div class="line"></div><div class="line">callback = callback || <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></div></pre></td></tr></table></figure></p>
<p>参考资料：<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对微信消息内容类型的判断]]></title>
      <url>/2017/05/15/parse_wechat_msgType/</url>
      <content type="html"><![CDATA[<p>最近试着做些工作总结，这也是我开始写博客的初衷，少bb，just do it！</p>
<p>这是我最早进公司做的一个小项目，需求是判断手机收发微信消息内容类型。就是手机发了一条微信消息之后，程序要能解析出发的是文本、语音还是图片等类型，并且统计时延。接收也是如此，主要需求是对发送类型的判断。<br><a id="more"></a></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1. 抓包
2. 解包
3. 结果展示
</code></pre><hr>
<h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><pre><code>该工作主要依赖部门内部高度定制的解析工具，可复现度几乎为0，因此全文只谈思路、方法与收获。
</code></pre><hr>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>抓取终端发生微信消息时的消息包，根据3GPP协议可以获取该消息的id为0x11EB</p>
<hr>
<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>这个过程就是把二进制的码流按照协议解析成有意义的字段。再从中筛选实际需要的内容做二次解析。<br>这部分按照当时使用的工具，解析语言用的lua。<br>这里主要说明下数据的过滤和解析</p>
<h4 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h4><p>如何判断数据是否有效？答案是<code>根据协议数据结构和自身业务需求</code>。<br>根据TCP/IP协议，数据包的格式是<code>Header + Data</code><br>这里具体来说就是，<code>ipHeader + tcpHeader + data</code>，其中data部分才是我们真正需要的解析目标。</p>
<hr>
<p>贴一下数据包的数据结构,分别对应IP数据包格式和TCP数据包格式，图片来源于网络<br>。更多内容可参考这篇文章<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="external">TCP协议</a><br><img src="http://opxo4bto2.bkt.clouddn.com/pic/lua/wechat/IP_Package.png" alt="ip"></p>
<p><img src="http://opxo4bto2.bkt.clouddn.com/pic/lua/wechat/TCP_Package.png" alt="tcp"></p>
<p>根据协议，很清楚可以看到ipHeader和tcpHeader的固定部分都是20个字节，因此协议规则如下：</p>
<hr>
<ul>
<li>ipHeader 至少20个字节</li>
<li>tcpHeader 至少20个字节<br>加上和业务定制的规则如下：</li>
<li>ipHeader 中的版本（0-4位对应的字段值）为4，即0100，用来表明IP协议实现的版本号，当前规定为IPv4，因此如果是连wifi发微信消息，那么就直接被过滤掉了</li>
<li>ipHeader中的协议（72-80位）为6，指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等，当前为TCP</li>
<li>data部分至少16个字节，这个是查资料获得，和微信消息类型相关的特征字信息，只在前16个字节中，后续字节内容应该表示的消息内容</li>
</ul>
<p>总的来说过滤数据，就是把不符合这五条规则的数据直接丢掉不处理，直接进入下一条log的处理。</p>
<hr>
<h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><p>假设我们已经获取数据，并过滤，得到了我们需要的data，下面开始处理，这里贴出当时写的很难看的处理函数。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataTypeFromDataContent</span><span class="params">(mo, buf)</span></span></div><div class="line">    <span class="keyword">local</span> ls = stat[mo]</div><div class="line">    <span class="keyword">local</span> str, dataSN = <span class="string">''</span>, <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">12</span>, <span class="number">1</span> <span class="keyword">do</span></div><div class="line">    	str = str..buf[i]..<span class="string">' '</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">13</span>, <span class="number">16</span>, <span class="number">1</span> <span class="keyword">do</span></div><div class="line">    	dataSN = dataSN..buf[i]</div><div class="line">    <span class="keyword">end</span></div><div class="line">    ls.dataSNText = dataSN</div><div class="line"> 	</div><div class="line">    <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 00 82 00 10 00 01 %x%x %x%x %x%x ED"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Text'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 %x%x %x%x 00 10 00 01 %x%x %x%x %x%x ED"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Text'</span>..<span class="string">'-'</span>..<span class="string">'Send'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 00 7E 00 10 00 01 %x%x %x%x %x%x 13"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Voice'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 00 81 00 10 00 01 %x%x %x%x %x%x 13"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Voice'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 00 83 00 10 00 01 %x%x %x%x %x%x 13"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Voice'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 %x%x %x%x 00 10 00 01 %x%x %x%x %x%x 13"</span>) <span class="keyword">then</span></div><div class="line">    	ls.dataType = <span class="string">'Voice'</span>..<span class="string">'-'</span>..<span class="string">'Send'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 27 14 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Img'</span>..<span class="string">'-'</span>..<span class="string">'Request'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 2A FC 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Img'</span>..<span class="string">'-'</span>..<span class="string">'Request OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 27 10 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Img'</span>..<span class="string">'-'</span>..<span class="string">'Send'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 2A F8 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Img'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span></div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 75 30 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Video'</span>..<span class="string">'-'</span>..<span class="string">'Send'</span>    </div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"AB 00 %x%x %x%x %x%x 79 18 00"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'Video'</span>..<span class="string">'-'</span>..<span class="string">'Send OK'</span> </div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">"00 00 %x%x %x%x 00 10 00 01"</span>) <span class="keyword">then</span></div><div class="line">        ls.dataType = <span class="string">'WeChat'</span>..<span class="string">'-'</span>..<span class="string">'unknown'</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这种全是if/else的代码着实难堪的，嗯，很符合当时的水平,说明如下：</p>
<pre><code>ls 为状态对象，是一个状态机的实现，用来记录每个手机实时的消息状态。
将data数组拼接成字符串，以空格为间隔。
可以看出，前12个字节用于判断类型，后四个字节用来记录序列号。
然后匹配对应各自的消息类型。
这些规则也是查阅资料论文和测试获得，微信也暂未公开这些信息。
</code></pre><hr>
<p>至此，已经可以获得消息类型了。当然只是常用的几种，文本，图片、语音及视频类型。但这里只完成了40%的任务，因为还需要统计发送消息的时延啊，例如发了一条消息，会马触发一条<code>Text-Send</code>的log，但直到有<code>Text-Send OK</code>的log上报，才会认定消息发送成功，二者之间的时间差就是需要记录的时延。</p>
<p>但理想很丰满，上面的消息判断依旧是很粗糙的，总有一些意外情况，例如<code>Send-OK</code>消息的格式总是有意外情况，图片会有分包的情况，如何判断是一次而不是多次发送等等问。</p>
<p>所以后来第二个迭代时就完全结束了这种不完全靠谱的做法，直接自定义两条log，在发送之前发一次，里面写好发送类型手机id等信息，发送完毕再发一条结束消息确认。这样来，一切就简单多了，相当于固定场景测试了。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下此次开发任务的收获和心得体会</p>
<ul>
<li><p>熟练掌握了lua的基本语法和使用，体验到了动态语言的优越性。</p>
</li>
<li><p>对IP数据包的结构有了基本认识，一切都是站在协议的肩膀上完成的</p>
</li>
<li><p>学会了如何分拆将一个稍微大点的任务分拆成小块，快速挖掘关注核心部分</p>
</li>
<li><p>收集资料的也是一种能力，懂业务比写代码实现更重要</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
            <category> Lua </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wechat </tag>
            
            <tag> message type </tag>
            
            <tag> lua </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
